
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Succinct Card Battle</title>
    <style>
        :root {
            --neon-pink: #ff2a6d;
            --neon-blue: #05d9e8;
            --neon-purple: #d300c5;
            --dark-bg: #0d0221;
            --darker-bg: #05010e;
            --card-width: 120px;
            --card-height: 180px;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
            font-family: 'Courier New', monospace;
        }

        body {
            background-color: var(--dark-bg);
            color: white;
            min-height: 100vh;
            position: relative;
            background-image: 
                radial-gradient(circle at 20% 30%, rgba(255, 42, 109, 0.15) 0%, transparent 25%),
                radial-gradient(circle at 80% 70%, rgba(5, 217, 232, 0.15) 0%, transparent 25%);
        }

        /* Main container */
        .game-container {
            display: flex;
            min-height: 100vh;
            position: relative;
        }

        /* Character selection screen */
        .character-select {
            position: relative;
            width: 100%;
            min-height: 100vh;
            background-color: var(--darker-bg);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            padding: 20px;
            text-align: center;
            overflow-y: auto;
        }

        .character-select h1 {
            color: var(--neon-pink);
            text-shadow: 0 0 10px var(--neon-pink);
            margin: 20px 0;
            font-size: 2.5rem;
        }

        .character-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 20px;
            max-width: 800px;
            margin-bottom: 30px;
            width: 100%;
        }

        .character-card {
            background: rgba(13, 2, 33, 0.7);
            border: 2px solid var(--neon-blue);
            border-radius: 10px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
        }

        .character-card.selected {
            border-color: var(--neon-pink);
            box-shadow: 0 0 20px var(--neon-pink);
            transform: scale(1.05);
        }

        .character-avatar {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            object-fit: cover;
            border: 2px solid var(--neon-purple);
            margin-bottom: 10px;
        }

        .character-name {
            color: var(--neon-blue);
            font-weight: bold;
            margin-top: 5px;
        }

        .special-move-info {
            display: none;
            background: rgba(5, 1, 14, 0.9);
            border: 1px solid var(--neon-pink);
            border-radius: 10px;
            padding: 10px;
            margin-top: 10px;
            width: 100%;
            text-align: center;
        }

        .character-card.selected .special-move-info {
            display: block;
            animation: fadeIn 0.3s ease;
        }

        .special-move-name {
            color: var(--neon-pink);
            font-weight: bold;
            margin-bottom: 5px;
        }

        /* Deck builder */
        .deck-builder {
            background: rgba(5, 1, 14, 0.9);
            border: 1px solid var(--neon-purple);
            border-radius: 10px;
            padding: 20px;
            max-width: 600px;
            margin: 20px 0;
            width: 100%;
        }

        .deck-builder h2 {
            color: var(--neon-blue);
            margin-bottom: 15px;
            text-align: center;
        }

        .card-options {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
        }

        .card-option {
            background: rgba(13, 2, 33, 0.7);
            border: 1px solid var(--neon-blue);
            border-radius: 5px;
            padding: 10px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
        }

        .card-option:hover {
            border-color: var(--neon-pink);
        }

        .card-option.selected {
            border-color: var(--neon-pink);
            box-shadow: 0 0 10px var(--neon-pink);
        }

        .start-game-btn {
            background: linear-gradient(45deg, var(--neon-pink), var(--neon-purple));
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 30px;
            font-size: 1.2rem;
            font-weight: bold;
            margin: 30px 0;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 0 15px var(--neon-purple);
        }

        .start-game-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 25px var(--neon-pink);
        }

        /* Battle UI */
        .battle-ui {
            display: flex;
            flex-direction: column;
            width: 100%;
            min-height: 100vh;
            padding: 20px;
            position: relative;
        }

        /* Player areas */
        .player-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            position: relative;
            min-height: 50vh;
        }

        .player-info {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 15px;
        }

        .battle-avatar {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            object-fit: cover;
            border: 2px solid var(--neon-blue);
            box-shadow: 0 0 10px var(--neon-blue);
        }

        .player-name {
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--neon-blue);
            text-shadow: 0 0 5px var(--neon-blue);
        }

        .health-container {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .health-bar {
            height: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            flex: 1;
            overflow: hidden;
        }

        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff2a6d, #ff7b00);
            width: 100%;
            transition: width 0.3s ease;
        }

        .health-text {
            min-width: 80px;
            text-align: center;
            font-weight: bold;
            color: white;
        }

        /* Card decks */
        .deck-area {
            display: flex;
            justify-content: center;
            gap: 15px;
            height: calc(var(--card-height) + 30px);
            align-items: center;
            flex-wrap: wrap;
            margin: 10px 0;
        }

        .card {
            width: var(--card-width);
            height: var(--card-height);
            background: linear-gradient(145deg, #1a1a2e, #2a2a4e);
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 15px;
            color: white;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
            position: relative;
            cursor: pointer;
            transition: all 0.3s;
            border: 1px solid var(--neon-blue);
            overflow: hidden;
        }

        .card::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: linear-gradient(45deg, var(--neon-blue), var(--neon-purple), var(--neon-pink));
            z-index: -1;
            border-radius: 12px;
            opacity: 0.7;
        }

        .card:hover {
            transform: translateY(-10px) scale(1.05);
            box-shadow: 0 10px 25px rgba(255, 42, 109, 0.5);
            border-color: var(--neon-pink);
        }

        .card.ai-card {
            background: linear-gradient(145deg, #2a2a4e, #3a3a6e);
            cursor: not-allowed;
        }

        .card.ai-card::before {
            background: linear-gradient(45deg, #555, #888);
        }

        .card-name {
            font-weight: bold;
            text-align: center;
            font-size: 1.1rem;
            margin-bottom: 5px;
            color: var(--neon-blue);
        }

        .card-icon {
            font-size: 3rem;
            text-align: center;
            margin: 10px 0;
            text-shadow: 0 0 10px currentColor;
        }

        .card.attack .card-icon {
            color: var(--neon-pink);
        }

        .card.heal .card-icon {
            color: #00ff9d;
        }

        .card-value {
            font-size: 1.5rem;
            font-weight: bold;
            text-align: center;
        }

        .card.attack .card-value {
            color: var(--neon-pink);
            text-shadow: 0 0 5px var(--neon-pink);
        }

        .card.heal .card-value {
            color: #00ff9d;
            text-shadow: 0 0 5px #00ff9d;
        }

        /* Special move button */
        .special-move-btn {
            background: linear-gradient(45deg, var(--neon-purple), var(--neon-pink));
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 20px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            margin-top: 10px;
            box-shadow: 0 0 10px var(--neon-purple);
        }

        .special-move-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 15px var(--neon-pink);
        }

        .special-move-btn:disabled {
            background: #555;
            color: #999;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }

        /* Battle log */
        .battle-log {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 350px;
            height: 200px;
            background-color: rgba(0, 0, 0, 0.7);
            border: 1px solid var(--neon-blue);
            border-radius: 5px;
            padding: 10px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            color: #00ff9d;
            box-shadow: 0 0 15px rgba(5, 217, 232, 0.3);
            z-index: 10;
        }

        .battle-log::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 30px;
            background: linear-gradient(to bottom, rgba(5, 217, 232, 0.3), transparent);
            pointer-events: none;
        }

        .log-entry {
            margin-bottom: 5px;
            padding-bottom: 5px;
            border-bottom: 1px solid rgba(5, 217, 232, 0.2);
            animation: fadeIn 0.3s ease;
        }

        /* Notification */
        .notification {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: var(--neon-pink);
            padding: 15px 30px;
            border-radius: 30px;
            font-size: 1.5rem;
            font-weight: bold;
            text-shadow: 0 0 10px var(--neon-pink);
            z-index: 100;
            animation: fadeInOut 5s ease forwards;
            background: transparent;
        }

        @keyframes fadeInOut {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
            20% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
            80% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
        }

        /* Turn indicator */
        .turn-indicator {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(45deg, var(--neon-pink), var(--neon-purple));
            color: white;
            padding: 8px 20px;
            border-radius: 20px;
            font-weight: bold;
            box-shadow: 0 0 15px var(--neon-purple);
            z-index: 10;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 10px var(--neon-purple); }
            50% { box-shadow: 0 0 20px var(--neon-pink); }
            100% { box-shadow: 0 0 10px var(--neon-purple); }
        }

        /* Effects */
        .damage-effect {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, rgba(255, 42, 109, 0.5) 0%, transparent 70%);
            animation: flash 0.5s;
        }

        .heal-effect {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, rgba(0, 255, 157, 0.5) 0%, transparent 70%);
            animation: flash 0.5s;
        }

        /* Victory/Defeat Effects */
        .victory-effect {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, rgba(0,255,157,0.7) 0%, transparent 70%);
            animation: fadeIn 1s ease forwards;
            z-index: 50;
            pointer-events: none;
        }

        .defeat-effect {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, rgba(255,42,109,0.7) 0%, rgba(13,2,33,0.9) 70%);
            animation: fadeIn 1s ease forwards;
            z-index: 50;
            pointer-events: none;
        }

        .draw-effect {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, rgba(5,217,232,0.7) 0%, rgba(13,2,33,0.9) 70%);
            animation: fadeIn 1s ease forwards;
            z-index: 50;
            pointer-events: none;
        }

        @keyframes flash {
            0% { opacity: 0; transform: scale(0.5); }
            50% { opacity: 1; transform: scale(1.1); }
            100% { opacity: 0; transform: scale(1); }
        }

        /* Controls */
        .controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            padding: 15px;
            margin-top: auto;
        }

        .control-btn {
            background: linear-gradient(45deg, var(--neon-blue), var(--neon-purple));
            color: white;
            border: none;
            padding: 10px 25px;
            border-radius: 25px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
            box-shadow: 0 0 10px var(--neon-blue);
        }

        .control-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 0 15px var(--neon-pink);
        }

        .control-btn:disabled {
            background: #555;
            color: #999;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }

        /* Animations */
        .card-play-anim {
            animation: cardPlay 0.5s ease forwards;
        }

        @keyframes cardPlay {
            0% { transform: translateY(0) scale(1); }
            50% { transform: translateY(-50px) scale(1.1); }
            100% { transform: translateY(0) scale(1); }
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(5px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Responsive Styles */
        @media (max-width: 768px) {
            :root {
                --card-width: 80px;
                --card-height: 120px;
            }

            .character-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 15px;
            }

            .card-options {
                grid-template-columns: repeat(2, 1fr);
            }

            .battle-log {
                width: calc(100% - 40px);
                height: 120px;
                bottom: 100px;
                left: 20px;
                right: 20px;
            }

            .player-info {
                flex-wrap: wrap;
            }

            .health-container {
                width: 100%;
                order: 3;
                margin-top: 10px;
            }

            .player-name {
                font-size: 1.2rem;
            }

            .battle-avatar {
                width: 40px;
                height: 40px;
            }

            .card {
                padding: 5px;
            }

            .card-name {
                font-size: 0.7rem;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
            }

            .card-icon {
                font-size: 1.5rem;
                margin: 5px 0;
            }

            .card-value {
                font-size: 1rem;
            }

            .deck-area {
                height: auto;
                min-height: calc(var(--card-height) + 20px);
                padding: 5px 0;
                gap: 8px;
                margin: 10px 0;
            }

            .special-move-btn {
                position: relative;
                width: 80%;
                max-width: 250px;
                margin: 10px auto;
                padding: 10px 20px;
                font-size: 1rem;
                background: linear-gradient(45deg, var(--neon-purple), var(--neon-pink));
                border: 1px solid var(--neon-pink);
                box-shadow: 0 0 15px rgba(210, 0, 197, 0.7);
                text-shadow: 0 0 5px rgba(0,0,0,0.5);
                order: 1;
            }

            .controls {
                flex-direction: column;
                gap: 10px;
                position: fixed;
                bottom: 10px;
                left: 0;
                right: 0;
                background: rgba(5, 1, 14, 0.9);
                padding: 10px;
                z-index: 10;
            }

            .control-btn {
                padding: 8px 15px;
            }

            .player-area {
                display: flex;
                flex-direction: column;
                padding-bottom: 80px;
            }

            .player-area > .player-info {
                order: 0;
            }
            .player-area > .deck-area {
                order: 1;
            }
            .player-area > .special-move-btn {
                order: 2;
            }

            .turn-indicator {
                font-size: 0.9rem;
                padding: 5px 15px;
                top: 10px;
            }

            .special-move-info {
                font-size: 0.7rem;
                padding: 5px;
            }

            .notification {
                font-size: 1.2rem;
                padding: 10px 20px;
            }
        }

        @media (max-width: 480px) {
            :root {
                --card-width: 70px;
                --card-height: 100px;
            }

            .character-select h1 {
                font-size: 1.8rem;
            }

            .character-avatar {
                width: 60px;
                height: 60px;
            }

            .character-name {
                font-size: 0.9rem;
            }

            .deck-builder h2 {
                font-size: 1.2rem;
            }

            .start-game-btn {
                padding: 10px 20px;
                font-size: 1rem;
            }

            .battle-log {
                height: 100px;
                font-size: 0.8rem;
            }

            .card {
                padding: 3px;
            }

            .card-name {
                font-size: 0.6rem;
            }

            .card-icon {
                font-size: 1.2rem;
            }

            .card-value {
                font-size: 0.8rem;
            }

            .deck-area {
                gap: 5px;
            }

            .special-move-btn {
                padding: 8px 15px;
                font-size: 0.9rem;
            }

            .notification {
                font-size: 1rem;
                padding: 8px 15px;
            }
        }
      /* Add to your CSS */
@keyframes shuffleDeck {
    0% { transform: translateY(0) rotate(0deg); }
    25% { transform: translateY(-20px) rotate(-5deg); }
    50% { transform: translateY(0) rotate(0deg); }
    75% { transform: translateY(-20px) rotate(5deg); }
    100% { transform: translateY(0) rotate(0deg); }
}

@keyframes dealCard {
    0% {
        transform: translate(-50%, -50%) rotateY(0deg) scale(0.8);
        opacity: 0;
        z-index: 10;
    }
    20% {
        opacity: 1;
        transform: translate(-50%, -50%) rotateY(180deg) scale(1);
    }
    100% {
        transform: translate(0, 0) rotateY(0deg) scale(1);
        opacity: 1;
        z-index: 1;
    }
}

@keyframes dealAICard {
    0% {
        transform: translate(-50%, -50%) rotateY(0deg) scale(0.8);
        opacity: 0;
        z-index: 10;
    }
    20% {
        opacity: 1;
        transform: translate(-50%, -50%) rotateY(180deg) scale(1);
    }
    100% {
        transform: translate(0, 0) rotateY(180deg) scale(1);
        opacity: 1;
        z-index: 1;
    }
}

.deck-shuffle {
    animation: shuffleDeck 0.5s ease-in-out 3;
}

.card-deal-animation {
    position: absolute;
    top: 50%;
    left: 50%;
    animation: dealCard 0.8s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
    transform-origin: center;
}

.ai-card-deal-animation {
    position: absolute;
    top: 50%;
    left: 50%;
    animation: dealAICard 0.8s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
    transform-origin: center;
}

.deck-placeholder {
    position: relative;
    width: var(--card-width);
    height: var(--card-height);
    background: rgba(255, 255, 255, 0.1);
    border-radius: 10px;
    margin: 0 5px;
    box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
    display: flex;
    justify-content: center;
    align-items: center;
    color: rgba(255, 255, 255, 0.3);
    font-size: 2rem;
}
#music-play-btn {
    background: linear-gradient(45deg, var(--neon-pink), var(--neon-purple));
    color: white;
    border: none;
    padding: 8px 15px;
    border-radius: 20px;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.3s;
    box-shadow: 0 0 10px var(--neon-purple);
    z-index: 1000;
}

#music-play-btn:hover {
    transform: scale(1.05);
    box-shadow: 0 0 15px var(--neon-pink);
} 
/* Main Menu Styles */
.main-menu {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center; /* Ensures vertical centering */
    width: 100%;
    min-height: 100vh; /* Ensures full viewport height coverage */
    padding: 20px; /* Prevents content from touching edges */
    box-sizing: border-box; /* Ensures padding doesn't affect width */
    text-align: center; /* Centers text for all child elements */
}

.main-menu h1 {
    color: var(--neon-pink);
    text-shadow: 0 0 10px var(--neon-pink);
    margin-bottom: 50px;
    font-size: 3rem;
    text-align: center;
}

.menu-options {
    display: flex;
    flex-direction: column;
    gap: 20px;
    width: 100%; /* Takes full width on mobile */
    max-width: 300px; /* Limits width on larger screens */
    align-items: center; /* Ensures buttons stay centered */
}

.menu-btn {
    background: linear-gradient(45deg, var(--neon-blue), var(--neon-purple));
    color: white;
    border: none;
    padding: 15px 30px;
    border-radius: 30px;
    font-size: 1.2rem;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.3s;
    box-shadow: 0 0 15px var(--neon-blue);
    text-align: center;
}

.menu-btn:hover {
    transform: scale(1.05);
    box-shadow: 0 0 25px var(--neon-pink);
}

@media (max-width: 768px) {
    .main-menu h1 {
        font-size: 2rem;
    }
    .menu-options {
        width: 250px;
    }
    .menu-btn {
        padding: 12px 25px;
        font-size: 1rem;
    }
}   
/* Add this to your existing media queries section */
@media (max-width: 768px) {
    .main-menu {
        padding: 15px;
        text-align: center;
    }

    .main-menu h1 {
        font-size: 2rem;
        margin-bottom: 30px;
    }

    .menu-options {
        width: 100%;
        max-width: 280px;
    }

    .menu-btn {
        padding: 12px 20px;
        font-size: 1rem;
    }
}

@media (max-width: 480px) {
    .main-menu h1 {
        font-size: 1.8rem;
        margin-bottom: 20px;
    }

    .menu-btn {
        padding: 10px 15px;
        font-size: 0.9rem;
    }
} 
.multiplayer-menu {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100vh;
  background: var(--darker-bg);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 1000;
}

#join-room-input {
  margin-top: 20px;
  display: flex;
  gap: 10px;
}

#join-room-input input {
  padding: 10px;
  border: 2px solid var(--neon-blue);
  background: var(--dark-bg);
  color: white;
  border-radius: 5px;
}
.deck-builder-buttons {
    display: flex;
    gap: 15px;
    justify-content: center;
    margin-top: 20px;
}

.multiplayer-btn {
    background: linear-gradient(45deg, var(--neon-blue), var(--neon-purple));
}
    </style>
</head>
<!-- Add this in the head section after the styles -->
<audio id="attack-sound" src="./sounds/slash.wav" preload="auto"></audio>
<audio id="fireball-sound" src="./sounds/fire.wav" preload="auto"></audio>
<audio id="crush-sound" src="./sounds/crush.wav" preload="auto"></audio>
<audio id="egg-sound" src="./sounds/egg.ogg" preload="auto"></audio>
<audio id="heal-sound" src="./sounds/heal.wav" preload="auto"></audio>
<audio id="special-sound" src="./sounds/special.wav" preload="auto"></audio>
<audio id="shield-sound" src="./sounds/shield.wav" preload="auto"></audio>
<audio id="victory-sound" src="./sounds/victory.mp3" preload="auto"></audio>
<audio id="defeat-sound" src="./sounds/defeat.wav" preload="auto"></audio>
<audio id="draw-sound" src="./sounds/draw.wav" preload="auto"></audio>
<audio id="dominance-sound" src="./sounds/dominance.mp3" preload="auto"></audio>
<audio id="cat-sound" src="./sounds/cat.mp3" preload="auto"></audio>
<audio id="clown-sound" src="./sounds/clown.mp3" preload="auto"></audio>
<audio id="batman-sound" src="./sounds/batman.mp3" preload="auto"></audio>
<audio id="love-sound" src="./sounds/love.mp3" preload="auto"></audio>
<audio id="eggy-sound" src="./sounds/egg.mp3" preload="auto"></audio>
<audio id="healer-sound" src="./sounds/healer.mp3" preload="auto"></audio>
<audio id="simp-sound" src="./sounds/simp.mp3" preload="auto"></audio>
<audio id="matrix-sound" src="./sounds/matrix.mp3" preload="auto"></audio>
<audio id="dictator-sound" src="./sounds/dictator.mp3" preload="auto"></audio>
<audio id="bg-music" loop>
  <source src="./sounds/battle.mp3" type="audio/mpeg">
  Play Music
</audio>
<body>
     <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
<script>
  
</script>
    <!-- Main Menu Screen -->
<div class="main-menu" id="main-menu">
    <h1>SUCCINCT CARD BATTLE</h1>
    <div class="menu-options">
        <button class="menu-btn" id="normal-mode-btn">NORMAL MODE</button>
        <button class="menu-btn" id="quit-btn">QUIT</button>
    </div>
</div>
    <!-- Character Selection Screen -->
    <div class="character-select" id="character-select">
        <h1>SELECT YOUR FIGHTER</h1>
        <div class="character-grid" id="character-grid">
            <!-- Characters will be added here by JS -->
        </div>
        <div class="deck-builder" id="deck-builder" style="display: none;">
            <h2>BUILD YOUR DECK</h2>
            <div class="card-options" id="card-options">
                <!-- Card options will be added here by JS -->
            </div>
        <button class="start-game-btn" id="start-game-btn">PLAY VS AI</button>
        <button class="start-game-btn multiplayer-btn" id="multiplayer-btn">PLAY MULTIPLAYER
        </div>
    </div>
    <!-- Add after character-select div -->
<div class="multiplayer-menu" id="multiplayer-menu" style="display:none;">
  <h1>MULTIPLAYER</h1>
  <div class="menu-options">
    <button id="create-room-btn">CREATE ROOM</button>
    <button id="join-room-btn">JOIN ROOM</button>
    <div id="join-room-input" style="display:none;">
      <input type="text" id="room-code" placeholder="Enter Room Code">
      <button id="submit-room-code">JOIN</button>
    </div>
    <div id="waiting-area" style="display:none;">
      <p>Room Code: <span id="room-code-display"></span></p>
      <p>Waiting for player...</p>
    </div>
  </div>
</div>

    <!-- Main Game UI -->
    <div class="game-container" id="game-container" style="display: none;">
        <div class="battle-ui">
             <!-- Player (Bottom) -->
            <div class="player-area">
                <div class="player-info">
                    <img class="battle-avatar" id="player-avatar" src="" alt="Player Avatar">
                    <div class="player-name" id="player-name">PLAYER</div>
                    <div class="health-container">
                        <div class="health-bar">
                            <div class="health-fill" id="player-health-bar"></div>
                        </div>
                        <div class="health-text" id="player-health-text">100/100</div>
                    </div>
                </div>
                <div class="deck-area" id="player-deck">
                <div class="deck-placeholder">âœ§</div>
                    <!-- Player cards will be added here -->
                </div>
                <button class="special-move-btn" id="special-move-btn" disabled>USE SPECIAL MOVE</button>
            </div>
            <!-- AI Player (Top) -->
            <div class="player-area">
                <div class="turn-indicator" id="turn-indicator">YOUR TURN</div>
                <div class="player-info">
                    <img class="battle-avatar" id="ai-avatar" src="" alt="AI Avatar">
                    <div class="player-name" id="ai-name">AI</div>
                    <div class="health-container">
                        <div class="health-bar">
                            <div class="health-fill" id="ai-health-bar"></div>
                        </div>
                        <div class="health-text" id="ai-health-text">100/100</div>
                    </div>
                </div>
                <div class="deck-area" id="ai-deck">
                     <div class="deck-placeholder">âœ§</div>
                    <!-- AI cards will be added here -->
                </div>
            </div>

            <!-- Battle Log -->
            <div class="battle-log" id="battle-log">
                <div class="log-entry">System initialized. Battle ready.</div>
            </div>

            <!-- Controls -->
            <div class="controls">
                <button class="control-btn" id="new-game-btn">NEW GAME</button>
                <button class="control-btn" id="restart-btn">RESTART MATCH</button>
            </div>
        </div>
    </div>

    <script>
        // Game Data
        const characters = [
            { 
                name: "Uma", 
                avatar: "./Avatars/Uma.webp",
                specialMove: {
                    name: "Founder Dominance",
                    description: "Deals 40 damage to opponent",
                    effect: function (user, target)  {
                        target.health -= 40;
                        if (target.health < 0) target.health = 0;
                        return `${user.name} uses Founder Dominance! Deals 40 damage to ${target.name}!`;
                    }
                }
            },
            { 
                name: "Zahar0n", 
                avatar: "./Avatars/Zahar0n.webp",
                specialMove: {
                    name: "I am Batman",
                    description: "Deals 25 damage to opponent",
                    effect: function (user, target) {
                        target.health -= 25;
                        if (target.health < 0) target.health = 0;
                        return `${user.name} uses I am Batman! Deals 25 damage to ${target.name}!`;
                    }
                }
            },
            { 
                name: "Saigon", 
                avatar: "./Avatars/Saigon.jpg",
                specialMove: {
                    name: "Cat Attack",
                    description: "Deals 20 damage to opponent",
                    effect: function (user, target)  {
                        target.health -= 20;
                        if (target.health < 0) target.health = 0;
                        return `${user.name} uses Cat Attack! Deals 20 damage to ${target.name}!`;
                    }
                }
            },
            { 
                name: "Yinger", 
                avatar: "./Avatars/Yinger.webp",
                specialMove: {
                    name: "Dictator",
                    description: "Deals 35 damage to opponent",
                    effect: function (user, target)  {
                        target.health -= 35;
                        if (target.health < 0) target.health = 0;
                        return `${user.name} uses Dictator! Deals 35 damage to ${target.name}!`;
                    }
                }
            },
            { 
                name: "Addy", 
                avatar: "./Avatars/Addy.webp",
                specialMove: {
                    name: "Eggscalibur",
                    description: "Deals 30 damage to opponent",
                    effect: function (user, target)  {
                        target.health -= 30;
                        if (target.health < 0) target.health = 0;
                        return `${user.name} uses Eggscalibur! Deals 30 damage to ${target.name}!`;
                    }
                }
            },
            { 
                name: "Stepaks", 
                avatar: "./Avatars/Stepaks.webp",
                specialMove: {
                    name: "Botman",
                    description: "Gets one additional turn",
                    effect: function (user, target)  {
                        user.extraTurns = 1;
                        return `${user.name} uses Botman! Gets one additional turn!`;
                    }
                }
            },
            { 
                name: "Pix", 
                avatar: "./Avatars/Pix.webp",
                specialMove: {
                    name: "Artiste",
                    description: "Heals 40 HP",
                    effect: function (user, target) {
                        user.health += 40;
                        if (user.health > 100) user.health = 100;
                        return `${user.name} uses Artiste! Heals 40 HP!`;
                    }
                }
            },
            { 
                name: "Cocowaves", 
                avatar: "./Avatars/Cocowaves.jpg",
                specialMove: {
                    name: "Queen",
                    description: "Gets one additional turn",
                    effect: function (user, target) {
                        user.extraTurns = 1;
                        return `${user.name} uses Queen! Gets one additional turn!`;
                    }
                }
            },
            { 
                name: "Zkdan", 
                avatar: "./Avatars/dan.webp",
                specialMove: {
                    name: "Labubu Rage",
                    description: "Deals 40 damage to opponent",
                    effect: function (user, target)  {
                        target.health -= 40;
                        if (target.health < 0) target.health = 0;
                        return `${user.name} uses Labubu Rage! Deals 40 damage to ${target.name}!`;
                    }
                }
            },
            { 
                name: "Bugs", 
                avatar: "./Avatars/Bugs.webp",
                specialMove: {
                    name: "Mr Helper",
                    description: "Heals 30 HP",
                    effect:function (user, target) {
                        user.health += 30;
                        if (user.health > 100) user.health = 100;
                        return `${user.name} uses Mr Helper! Heals 30 HP!`;
                    }
                }
            },
            { 
                name: "Tuong", 
                avatar: "./Avatars/Tuong.webp",
                specialMove: {
                    name: "Mr Green",
                    description: "Heals 25 HP",
                    effect: function (user, target) {
                        user.health += 25;
                        if (user.health > 100) user.health = 100;
                        return `${user.name} uses Mr Green! Heals 25 HP!`;
                    }
                }
            },
            { 
                name: "Chixxey", 
                avatar: "./Avatars/Chixxey.webp", 
                specialMove: {
                    name: "Love Bomb",
                    description: "Deals 5 damage to opponent and gets an extra turn",
                    effect: function (user, target) {
                        target.health -= 5;
                        if (target.health < 0) target.health = 0;
                        user.extraTurns = 1;
                        return `${user.name} uses Love Bomb! Deals 5 damage to ${target.name} and gets an extra turn!`;
                    }
                }
            },

            
            { 
                name: "Wylo", 
                avatar: "./Avatars/Wylo.jpg",
                specialMove: {
                    name: "The Clown",
                    description: "Deals 35 damage to himself",
                    effect: function (user, target)  {
                        user.health -= 35;
                        if (user.health < 0) user.health = 0;
                        return `${user.name} uses The Clown! Deals 35 damage to himself!`;
                    }
                }
            },

          { 
    name: "Serkan", 
    avatar: "./Avatars/Serkan.jpg",
    specialMove: {
        name: "Matrix Glitch",
        description: "His next attack deals double damage",
        effect: function (user, target) {
            // Set flag for next attack
            user.nextAttackDoubled = true;
            return `${user.name} uses Matrix Glitch! Next attack will deal double damage!`;
        }
    }
},
    { 
        name: "Jekyde", 
        avatar: "./Avatars/Jekyde.jpg",
        specialMove: {
            name: "Mr Shipper",
            description: "+20 HP to himself and -20 HP to opponent",
            effect: function (user, target) {
                // Heal user
                user.health += 20;
                if (user.health > 100) user.health = 100;
                
                // Damage opponent
                target.health -= 20;
                if (target.health < 0) target.health = 0;
                
                return `${user.name} uses Mr Shipper! +20 HP to himself and -20 HP to ${target.name}!`;
            }
        }
    },
    { 
        name: "ZkTug", 
        avatar: "./Avatars/Tug.jpg",
        specialMove: {
            name: "Proofer Regen",
            description: "Heals 40 HP ",
            effect: function (user, target) {
                user.health += 40;
                if (user.health > 100) user.health = 100;
                return `${user.name} uses Proofer Regen! +40 HP!`;
            }
        }
    },
   { 
    name: "Shoeb", 
    avatar: "./Avatars/Shoeb.jpg",
    specialMove: {
        name: "The Don",
        description: "Deals 30 damage to opponent and 10 damage to himself",
        effect: function (user, target) {
            target.health -= 30;
            if (target.health < 0) target.health = 0;
            user.health -= 10;
            if (user.health < 0) user.health = 0;
            return `${user.name} uses The Don! Deals 30 damage to ${target.name} and 10 damage to himself!`;
        }
    }
},
{ 
    name: "Rob", 
    avatar: "./Avatars/Rob.jpg",
    specialMove: {
        name: "Mr Simp",
        description: "Deals 30 damage to himself against female characters, and 10 damage to male opponents",
        effect: function (user, target)  {
            const femaleCharacters = ["Uma", "Cocowaves", "Chixxey", "Pix"];
            if (femaleCharacters.includes(target.name)) {
                user.health -= 30;
                if (user.health < 0) user.health = 0;
                return `${user.name} uses Mr Simp against ${target.name}! Deals 30 damage to himself!`;
            } else {
                target.health -= 10;
                if (target.health < 0) target.health = 0;
                return `${user.name} uses Mr Simp! Deals 10 damage to ${target.name}!`;
            }
        }
    }
}
            
        ];

      const allCardTypes = [
    { name: "Slash", type: "attack", power: 15, icon: "âš”ï¸" },
    { name: "Fireball", type: "attack", power: 20, icon: "ðŸ”¥" },
    { name: "Crush", type: "attack", power: 25, icon: "ðŸ”¨" },
    { name: "Pierce", type: "attack", power: 18, icon: "ðŸ—¡ï¸" },
    { name: "Heal", type: "heal", power: 10, icon: "â¤ï¸" },
    { name: "Cure", type: "heal", power: 15, icon: "âœ¨" },
    { name: "Revive", type: "heal", power: 15, icon: "ðŸŒ¿" },
    { name: "Shield", type: "block", power: 0, icon: "ðŸ›¡ï¸", description: "Blocks half of next attack's damage" } ,
    { name: "Egg", type: "attack", power: 28, icon: "ðŸ¥š" } 
];

            let roomId = null;
        // Game State
        const gameState = {
            player: null,
            ai: null,
            currentTurn: "player",
            gameOver: false,
            selectedCards: [],
            specialMoveUsed: false,
            nextAttackDoubled:false,
            isMultiplayer: false,
            opponent: null 
        };

        // DOM Elements
        const elements = {
            characterSelect: document.getElementById('character-select'),
            characterGrid: document.getElementById('character-grid'),
            deckBuilder: document.getElementById('deck-builder'),
            cardOptions: document.getElementById('card-options'),
            startGameBtn: document.getElementById('start-game-btn'),
            gameContainer: document.getElementById('game-container'),
            playerName: document.getElementById('player-name'),
            aiName: document.getElementById('ai-name'),
            playerAvatar: document.getElementById('player-avatar'),
            aiAvatar: document.getElementById('ai-avatar'),
            playerHealthBar: document.getElementById('player-health-bar'),
            aiHealthBar: document.getElementById('ai-health-bar'),
            playerHealthText: document.getElementById('player-health-text'),
            aiHealthText: document.getElementById('ai-health-text'),
            playerDeck: document.getElementById('player-deck'),
            aiDeck: document.getElementById('ai-deck'),
            battleLog: document.getElementById('battle-log'),
            turnIndicator: document.getElementById('turn-indicator'),
            restartBtn: document.getElementById('restart-btn'),
            newGameBtn: document.getElementById('new-game-btn'),
            specialMoveBtn: document.getElementById('special-move-btn'),
            mainMenu: document.getElementById('main-menu'),
            normalModeBtn: document.getElementById('normal-mode-btn'),
            multiplayerBtn: document.getElementById('multiplayer-btn'),
            quitBtn: document.getElementById('quit-btn'),
            multiplayerMenu: document.getElementById('multiplayer-menu'),
            createRoomBtn: document.getElementById('create-room-btn'),
            joinRoomBtn: document.getElementById('join-room-btn'),
            joinRoomInput: document.getElementById('join-room-input'),
            roomCodeInput: document.getElementById('room-code'),
            submitRoomCode: document.getElementById('submit-room-code'),
             waitingArea: document.getElementById('waiting-area'),
             roomCodeDisplay: document.getElementById('room-code-display')
        };

        
    // Socket.io connection
    const socket = io('https://card-battle-u4uz.onrender.com/');
    
    // Socket event handlers
    socket.on('connect', () => {
        gameState.socketId = socket.id;
        console.log('Connected to server with ID:', socket.id);
    });

   socket.on('roomCreated', ({ roomId }) => {
    console.log("âœ… Room created:", roomId);
    elements.waitingArea.style.display = 'block';
    elements.roomCodeDisplay.textContent = roomId;
    gameState.roomId = roomId;
    addToLog(`Room created. Code: ${roomId}. Waiting for opponent...`);
});


    socket.on('playerJoined', ({ players, roomId }) => {
  console.log("ðŸŽ¯ playerJoined:", players, roomId);

  gameState.opponent = players.find(p => p.socketId !== socket.id);
  gameState.isMultiplayer = true;
  gameState.roomId = roomId;

  addToLog(`Opponent joined: ${gameState.opponent.name}`);

  // Mark yourself ready
  socket.emit('playerReady', {
    roomId,
    deck: gameState.selectedCards,
    specialMove: gameState.player.specialMove
  });
});


   socket.on('gameStarted', ({ players, currentTurn }) => {
    console.log("ðŸ§ª gameStarted data:", players);

  elements.multiplayerMenu.style.display = 'none';
  elements.gameContainer.style.display = 'flex';

  if (!Array.isArray(players) || players.length !== 2) {
    console.error("Invalid players array:", players);
    return;
  }

  const localPlayer = players.find(p => p.socketId === socket.id);
  const opponent = players.find(p => p.socketId !== socket.id);

  if (!localPlayer || !opponent) {
    console.error("Failed to assign localPlayer or opponent", { players, socketId: socket.id });
    return;
  }

  gameState.player = {
    ...localPlayer,
    extraTurns: 0,
    shieldActive: false,
    nextAttackDoubled: false,
    specialMove: localPlayer.specialMove,
    specialMoveUsed: false,
    health: localPlayer.health ?? 100
  };

  gameState.opponent = {
    ...opponent,
    extraTurns: 0,
    shieldActive: false,
    nextAttackDoubled: false,
    specialMoveUsed:  false,
    health: opponent.health ?? 100
  };

  gameState.currentTurn = currentTurn === socket.id ? "player" : "opponent";
  gameState.isMultiplayer = true;
  gameState.roomId = gameState.roomId || localPlayer.roomId; // fallback

  playBackgroundMusic();

  elements.aiName.textContent = gameState.opponent.name;
  elements.aiAvatar.src = gameState.opponent.avatar;

  console.log("ðŸŽ´ Your deck:", gameState.player.deck);
  console.log("ðŸ§  Opponent:", gameState.opponent);

  updateUI();
  animateCardsDrop(); // Ensure deck is loaded before this

  addToLog(`Battle begins: ${gameState.player.name} vs ${gameState.opponent.name}`);
  addToLog(gameState.currentTurn === "player"
    ? "You go first!"
    : `${gameState.opponent.name} goes first!`);
});



    socket.on('cardPlayed', ({ playerId, cardIndex }) => {
        if (playerId === socket.id) return;
        
        const opponent = gameState.opponent;
        const card = opponent.deck[cardIndex];
        
        applyCardEffects(card, opponent, gameState.player);
        updateUI();
        
        gameState.currentTurn = "player";
        elements.turnIndicator.textContent = "YOUR TURN";
    });

    socket.on('gameStateUpdated', (updatedState) => {
        const localPlayer = updatedState.players.find(p => p.socketId === socket.id);
        const opponent = updatedState.players.find(p => p.socketId !== socket.id);
        
        gameState.player = {
            ...gameState.player,
            health: localPlayer.health,
            specialMoveUsed: localPlayer.specialMoveUsed
        };
        
        gameState.opponent = {
            ...gameState.opponent,
            health: opponent.health,
            specialMoveUsed: opponent.specialMoveUsed
        };
        
        gameState.currentTurn = updatedState.currentTurn === socket.id ? "player" : "opponent";
        updateUI();
    });
    // Add this with your other socket handlers
socket.on('specialMoveApplied', ({ playerId, message, playerHealth, opponentHealth, extraTurn, doubleDamage }) => {
    if (playerId === socket.id) {
        // We already handled the local effects
        if (doubleDamage) {
            gameState.player.nextAttackDoubled = true;
        }
        return;
    }
    
    // Update health values
    gameState.player.health = playerHealth;
    gameState.opponent.health = opponentHealth;
    
    // Update special move effects
    if (doubleDamage) {
        gameState.opponent.nextAttackDoubled = true;
    }
    
    // Add to log
    addToLog(message);
    
    // Update UI
    updateUI();
    
    // Switch turns if it wasn't an extra turn move
    if (!extraTurn) {
        gameState.currentTurn = "player";
        elements.turnIndicator.textContent = "YOUR TURN";
    }
});

    socket.on('gameOver', ({ winner }) => {
        gameState.gameOver = true;
        
        if (winner === socket.id) {
            showNotification("YOU WIN!");
            playVictorySound();
            addToLog("You won the battle!");
        } else {
            showNotification("YOU LOSE!");
            playDefeatSound();
            addToLog("You lost the battle!");
        }
        
        document.querySelectorAll('.card').forEach(card => {
            card.style.pointerEvents = 'none';
        });
        elements.specialMoveBtn.disabled = true;
    });

    // Add this with your other socket handlers
socket.on('specialMoveApplied', ({ playerId, message, playerHealth, opponentHealth }) => {
    if (playerId === socket.id) {
        // This is our own move, we already handled it locally
        return;
    }

    // Update opponent's special move status
    gameState.opponent.specialMoveUsed = true;
    
    // Update health values
    gameState.player.health = playerHealth;
    gameState.opponent.health = opponentHealth;
    
    // Add to log
    addToLog(message);
    
    // Update UI
    updateUI();
    
    // Switch turns
    gameState.currentTurn = "player";
    elements.turnIndicator.textContent = "YOUR TURN";
});

    socket.on('opponentDisconnected', () => {
        showNotification("Opponent disconnected!");
        addToLog("Opponent disconnected. Returning to main menu.");
        
        setTimeout(() => {
            newGame();
        }, 3000);
    });

    socket.on('error', (message) => {
        showNotification(`Error: ${message}`);
    });

   socket.on('specialMoveUsed', ({ playerId }) => {
    if (playerId === socket.id) return;
    
    const opponent = gameState.opponent;
    const player = gameState.player;
    
    // Mark opponent's special move as used
    opponent.specialMoveUsed = true;
    
    // Apply the effect
    const message = opponent.specialMove.effect(opponent, player);
    addToLog(message);
    
    updateUI();
    
    // Check for game over
    if (player.health <= 0 || opponent.health <= 0) {
        endGame();
    }
});
        
// Multiplayer event listeners
    elements.multiplayerBtn.addEventListener('click', () => {
        elements.mainMenu.style.display = 'none';
        elements.multiplayerMenu.style.display = 'flex';
    });

    elements.createRoomBtn.addEventListener('click', () => {
    if (gameState.selectedCards.length === 5) {
        socket.emit('createRoom', {
            name: gameState.player.name,
            avatar: gameState.player.avatar,
            deck: gameState.selectedCards,
            specialMove:{ 
                name: gameState.player.specialMove.name,
                description: gameState.player.specialMove.description,
                effect: gameState.player.specialMove.effect.toString()
                }
        });
    } else {
        alert("Please build your deck first!");
    }
});

    elements.joinRoomBtn.addEventListener('click', () => {
        elements.joinRoomInput.style.display = 'flex';
    });

    elements.submitRoomCode.addEventListener('click', () => {
        const code = elements.roomCodeInput.value.trim().toUpperCase();
        if (code) {
            if (!gameState.player) {
                alert("Please select your character and deck first");
                return;
            }
            
            socket.emit('joinRoom', {
                roomId: code,
                playerData: {
                    name: gameState.player.name,
                    avatar: gameState.player.avatar,
                    deck: gameState.selectedCards,
                    specialMove:{
                        name: gameState.player.specialMove .name,
                        description: gameState.player.specialMove.description
                    }
                }
            });
        }
    });

    // Helper function to apply card effects
    function applyCardEffects(card, user, target) {
        if (card.name === "Crush") playCrushSound();
        else if (card.name === "Egg") playEggSound();
        else if (card.type === "attack") playAttackSound();
        else if (card.type === "heal") playHealSound();
        else if (card.name === "Shield") playShieldSound();

        if (card.type === "attack" || card.name === "Egg") {
            let damage = card.power;
            
            if (user.nextAttackDoubled) {
                damage *= 2;
                addToLog(`Matrix Glitch doubles ${card.name}'s power to ${damage}!`);
                user.nextAttackDoubled = false;
            }
            
            if (target.shieldActive) {
                damage = Math.max(1, Math.floor(damage / 2));
                addToLog(`${target.name}'s Shield reduces damage to ${damage}!`);
                target.shieldActive = false;
            }
            
            target.health -= damage;
            if (target.health < 0) target.health = 0;
            addToLog(`${user.name} uses ${card.name} for ${damage} damage!`);
        } 
        else if (card.type === "heal") {
            const healAmount = card.power;
            user.health += healAmount;
            if (user.health > 100) user.health = 100;
            addToLog(`${user.name} heals for ${healAmount} HP!`);
        }
        else if (card.name === "Shield") {
            user.shieldActive = true;
            addToLog(`${user.name} activates Shield! Next attack will be halved!`);
        }
    }

        // Add this near your other sound functions
function playBackgroundMusic() {
    const bgMusic = document.getElementById('bg-music');
    bgMusic.volume = 0.15; // Set lower volume so it's not overwhelming
    // Try to play, and if blocked, show a play button
    const promise = bgMusic.play();
    
    if (promise !== undefined) {
        promise.catch(error => {
            // Autoplay was prevented, show a play button
            showMusicPlayButton();
        });
    }
}

function showMusicPlayButton() {
    const playButton = document.createElement('button');
    playButton.id = 'music-play-btn';
    playButton.textContent = 'â–¶ Play Music';
    playButton.style.position = 'fixed';
    playButton.style.bottom = '20px';
    playButton.style.left = '20px';
    playButton.style.zIndex = '100';
    playButton.style.padding = '10px 15px';
    playButton.style.borderRadius = '20px';
    playButton.style.background = 'linear-gradient(45deg, var(--neon-pink), var(--neon-purple))';
    playButton.style.color = 'white';
    playButton.style.border = 'none';
    playButton.style.cursor = 'pointer';
    
    playButton.addEventListener('click', () => {
        document.getElementById('bg-music').play();
        playButton.remove();
    });
    
    document.body.appendChild(playButton);
}

        function playAttackSound() {
    const sound = document.getElementById('attack-sound');
    sound.currentTime = 0;
    sound.play();
}

function playCrushSound() {
    const sound = document.getElementById('crush-sound');
    sound.currentTime = 0;
    sound.play();
}
function playEggSound() {
    const sound = document.getElementById('egg-sound');
    sound.currentTime = 0;
    sound.play();
}

function playHealSound() {
    const sound = document.getElementById('heal-sound');
    sound.currentTime = 0;
    sound.play();
}
function playEggySound() {
    const sound = document.getElementById('eggy-sound');
    sound.currentTime = 0;
    sound.play();
}
function playMatrixSound() {
    const sound = document.getElementById('matrix-sound');
    sound.currentTime = 0;
    sound.play();
}
function playLoveSound() {
    const sound = document.getElementById('love-sound');
    sound.currentTime = 0;
    sound.play();
}
function playCatSound() {
    const sound = document.getElementById('cat-sound');
    sound.currentTime = 0;
    sound.play();
}
function playDictatorSound() {
    const sound = document.getElementById('dictator-sound');
    sound.currentTime = 0;
    sound.play();
}
function playHealerSound() {
    const sound = document.getElementById('healer-sound');
    sound.currentTime = 0;
    sound.play();
}
function playSimpSound() {
    const sound = document.getElementById('simp-sound');
    sound.currentTime = 0;
    sound.play();
}

function playShieldSound() {
    const sound = document.getElementById('shield-sound');
    sound.currentTime = 0;
    sound.play();
}
function playFireballSound() {
    const sound = document.getElementById('fireball-sound');
    sound.currentTime = 0;
    sound.play();
}
function playClownSound() {
    const sound = document.getElementById('clown-sound');
    sound.currentTime = 0;
    sound.play();
}

function playVictorySound() {
    const sound = document.getElementById('victory-sound');
    sound.currentTime = 0;
    sound.play();
}
function playBatmanSound() {
    const sound = document.getElementById('batman-sound');
    sound.currentTime = 0;
    sound.play();
}
function playDominanceSound() {
    const sound = document.getElementById('dominance-sound');
    sound.currentTime = 0;
    sound.play();
}

function playDefeatSound() {
    const sound = document.getElementById('defeat-sound');
    sound.currentTime = 0;
    sound.play();
}
function playSpecialSound() {
    const sound = document.getElementById('special-sound');
    sound.currentTime = 0;
    sound.play();
}
        
        // Show notification
        function showNotification(message, duration = 5000) {
            const notification = document.createElement('div');
            notification.className = 'notification';
            notification.textContent = message;
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.remove();
            }, duration);
        }

        // Initialize Character Selection
        function initCharacterSelection() {
            elements.characterGrid.innerHTML = '';
            characters.forEach((character, index) => {
                const charElement = document.createElement('div');
                charElement.className = 'character-card';
                charElement.innerHTML = `
                    <img class="character-avatar" src="${character.avatar}" alt="${character.name}">
                    <div class="character-name">${character.name}</div>
                    <div class="special-move-info">
                        <div class="special-move-name">${character.specialMove.name}</div>
                        ${character.specialMove.description}
                    </div>
                `;
                charElement.addEventListener('click', () => selectCharacter(character, charElement));
                elements.characterGrid.appendChild(charElement);
            });
        }

        // Select Character
        function selectCharacter(character, element) {
            // Remove previous selection
            document.querySelectorAll('.character-card').forEach(card => {
                card.classList.remove('selected');
            });
            
            // Set new selection
            element.classList.add('selected');
            gameState.player = {
                name: character.name,
                avatar: character.avatar,
                health: 100,
                deck: [],
                isAI: false,
                specialMove: character.specialMove,
                specialMoveUsed: false,
                extraTurns: 0,
                shieldActive: false,
                glitchActive: false,
                glitchTurns: 0,
                nextAttackDoubled: false
            };
            
            // Show deck builder
            elements.deckBuilder.style.display = 'block';
            initDeckBuilder();
        }

        // Initialize Deck Builder
        function initDeckBuilder() {
            elements.cardOptions.innerHTML = '';
            allCardTypes.forEach((card, index) => {
                const cardElement = document.createElement('div');
                cardElement.className = 'card-option';
                cardElement.innerHTML = `
                    <div style="font-size: 2rem;">${card.icon}</div>
                    <div>${card.name}</div>
                    <div>${card.power} ${card.type === 'attack' ? 'DMG' : 'HEAL'}</div>
                `;
                cardElement.addEventListener('click', () => toggleCardSelection(card, cardElement));
                elements.cardOptions.appendChild(cardElement);
                // Inside your deck-builder code

            });
        }

        // Toggle Card Selection
        function toggleCardSelection(card, element) {
            const index = gameState.selectedCards.findIndex(c => c.name === card.name);
            
            if (index === -1) {
                if (gameState.selectedCards.length < 5) {
                    gameState.selectedCards.push(card);
                    element.classList.add('selected');
                }
            } else {
                gameState.selectedCards.splice(index, 1);
                element.classList.remove('selected');
            }
        }

        // Start Game
        function startGame() {
            if (gameState.selectedCards.length !== 5) {
                alert("Please select exactly 5 cards for your deck!");
                return;
            }
             playBackgroundMusic();
            // Hide character select, show game
            elements.characterSelect.style.display = 'none';
            elements.gameContainer.style.display = 'flex';
            
            // Set up AI with random character
            const aiCharacter = characters[Math.floor(Math.random() * characters.length)];
            gameState.ai = {
                name: aiCharacter.name,
                avatar: aiCharacter.avatar,
                health: 100,
                deck: generateRandomDeck(),
                isAI: true,
                specialMove: aiCharacter.specialMove,
                specialMoveUsed: false,
                extraTurns: 0,
                shieldActive: false,
                glitchActive: false,
                glitchTurns: 0
            };
            
            // Set player deck from selected cards
            gameState.player.deck = [...gameState.selectedCards];
            gameState.specialMoveUsed = false;
            
            // Initialize battle
            initBattle();

            
        }
       function animateCardsDrop() {
    // Clear existing cards but keep placeholders
    const playerCards = elements.playerDeck.querySelectorAll('.card:not(.deck-placeholder)');
    const aiCards = elements.aiDeck.querySelectorAll('.card:not(.deck-placeholder)');
    playerCards.forEach(card => card.remove());
    aiCards.forEach(card => card.remove());
    
    // Create a central deck element for animation
    const centralDeck = document.createElement('div');
    centralDeck.className = 'deck-placeholder deck-shuffle';
    centralDeck.style.position = 'fixed';
    centralDeck.style.top = '50%';
    centralDeck.style.left = '50%';
    centralDeck.style.transform = 'translate(-50%, -50%)';
    centralDeck.style.zIndex = '100';
    document.body.appendChild(centralDeck);
    
    // First show the deck being shuffled
    setTimeout(() => {
        // After shuffle animation completes, deal exactly 5 cards to each player
        centralDeck.remove();
        dealCards();
    }, 1500);
}

function dealCards() {
    // Clear existing cards but keep placeholders
    elements.playerDeck.innerHTML = '<div class="deck-placeholder">âœ§</div>';
    elements.aiDeck.innerHTML = '<div class="deck-placeholder">âœ§</div>';
    
    // Deal exactly 5 player cards (face up)
    for (let i = 0; i < 5; i++) {
        setTimeout(() => {
            // Create card element with all details
            const card = gameState.player.deck[i];
            const cardElement = document.createElement('div');
            cardElement.className = `card ${card.type}`;
            cardElement.innerHTML = `
                <div class="card-name">${card.name}</div>
                <div class="card-icon">${card.icon}</div>
                <div class="card-value">${card.power}</div>
            `;
            
            // Add animation class
            cardElement.classList.add('card-deal-animation');
            elements.playerDeck.appendChild(cardElement);
            
            // After animation completes
            setTimeout(() => {
                cardElement.classList.remove('card-deal-animation');
                cardElement.style.position = '';
                cardElement.style.top = '';
                cardElement.style.left = '';
                
                // Add click handler with correct index
                cardElement.addEventListener('click', () => playCard(i));
            }, 800);
        }, i * 300); // Stagger each card by 300ms
    }
    
    // Deal exactly 5 AI cards (face down)
    for (let i = 0; i < 5; i++) {
        setTimeout(() => {
            const cardElement = document.createElement('div');
            cardElement.className = 'card ai-card';
            cardElement.innerHTML = `<div style="font-size: 2rem;">â“</div>`;
            cardElement.classList.add('ai-card-deal-animation');
            elements.aiDeck.appendChild(cardElement);
            
            setTimeout(() => {
                cardElement.classList.remove('ai-card-deal-animation');
                cardElement.style.position = '';
                cardElement.style.top = '';
                cardElement.style.left = '';
            }, 800);
        }, (i + 5) * 300); // Start AI cards after player cards
    }
    
    // Final setup after all animations complete
    setTimeout(() => {
        // Remove placeholders
        elements.playerDeck.querySelector('.deck-placeholder')?.remove();
        elements.aiDeck.querySelector('.deck-placeholder')?.remove();
        
        // Update game state
        elements.turnIndicator.style.display = 'block';
       addToLog(`Battle begins: ${gameState.player.name} vs ${gameState.isMultiplayer ? gameState.opponent.name : gameState.ai.name}`);
        addToLog(`Player goes first!`);
    }, 3000); // Wait for all animations to finish 
}
function getRandomCard() {
    // Helper function to get a random card from all available types
    const randomIndex = Math.floor(Math.random() * allCardTypes.length);
    return {...allCardTypes[randomIndex]};
}

        // Generate Random Deck for AI
       function generateRandomDeck() {
    const deck = [];
    const attackCards = allCardTypes.filter(card => card.type === "attack");
    const healCards = allCardTypes.filter(card => card.type === "heal");
    const blockCards = allCardTypes.filter(card => card.name === "Shield");
    
    // Add 3 attack (can include Egg), 1 heal, and 1 shield
    for (let i = 0; i < 3; i++) {
        deck.push({...attackCards[Math.floor(Math.random() * attackCards.length)]});
    }
    deck.push({...healCards[Math.floor(Math.random() * healCards.length)]});
    deck.push({...blockCards[0]}); // Add shield
    
    return deck;
}
function createCardElement(card) {
    const cardElement = document.createElement('div');
    cardElement.className = `card ${card.type}`;
    cardElement.innerHTML = `
        <div class="card-name">${card.name}</div>
        <div class="card-icon">${card.icon}</div>
        <div class="card-value">${card.power}</div>
    `;
    return cardElement;
}

        // Initialize Battle
        function initBattle() {
            gameState.gameOver = false;
            gameState.currentTurn = "player";
            gameState.specialMoveUsed = false;
            gameState.player.extraTurns = 0;
            gameState.ai.extraTurns = 0;
            
            // Show turn indicator
            elements.turnIndicator.style.display = 'none';
            
            // Update UI
            updateUI();

            animateCardsDrop();

             const totalCards = gameState.player.deck.length + gameState.ai.deck.length;
    setTimeout(() => {
        elements.turnIndicator.style.display = 'block';
    }, totalCards * 300 + 1000);
           
        }

        // Update UI
     function updateUI() {
    if (!gameState.player || (!gameState.ai && !gameState.opponent)) return;

    const opponent = gameState.isMultiplayer ? gameState.opponent : gameState.ai;
    if (!opponent) {
        console.warn("Opponent not ready yet", gameState);
        return;
    }
    if (!gameState.player.specialMove) {
  console.error("âŒ specialMove is undefined!", gameState.player);
  elements.specialMoveBtn.textContent = "SPECIAL MOVE ERROR";
  return;
}

    // Player Info
    elements.playerName.textContent = gameState.player.name;
    elements.playerAvatar.src = gameState.player.avatar;
    elements.playerHealthBar.style.width = `${gameState.player.health}%`;
    elements.playerHealthText.textContent = `${gameState.player.health}/100`;

    // Opponent Info
    elements.aiName.textContent = opponent.name;
    elements.aiAvatar.src = opponent.avatar;
    elements.aiHealthBar.style.width = `${opponent.health}%`;
    elements.aiHealthText.textContent = `${opponent.health}/100`;

    // Turn Indicator
    elements.turnIndicator.textContent =
        gameState.currentTurn === "player"
            ? "YOUR TURN"
            : `${opponent.name.toUpperCase()}'S TURN`;

    // Special Move Button
    elements.specialMoveBtn.disabled =
        gameState.currentTurn !== "player" ||
        gameState.player.specialMoveUsed ||
        gameState.gameOver;

   elements.specialMoveBtn.textContent = gameState.player.specialMoveUsed
  ? "SPECIAL MOVE USED"
  : `USE ${gameState.player.specialMove?.name || "SPECIAL"}`;

    // Render Cards
    renderDecks();
}

        // Render Decks
       function renderDecks() {
    elements.playerDeck.innerHTML = '';
    elements.aiDeck.innerHTML = '';

    // Player Cards
    gameState.player.deck.forEach((card, index) => {
        const cardElement = document.createElement('div');
        cardElement.className = `card ${card.type}`;
        cardElement.innerHTML = `
            <div class="card-name">${card.name}</div>
            <div class="card-icon">${card.icon}</div>
            <div class="card-value">${card.power}</div>
        `;
        if (gameState.currentTurn === "player" && !gameState.gameOver) {
            cardElement.addEventListener('click', () => playCard(index));
        }
        elements.playerDeck.appendChild(cardElement);
    });

    // Opponent Cards (face down)
    const opponentDeck = gameState.isMultiplayer ? gameState.opponent.deck : gameState.ai.deck;

    opponentDeck.forEach(() => {
        const cardElement = document.createElement('div');
        cardElement.className = 'card ai-card';
        cardElement.innerHTML = `<div style="font-size: 2rem;">â“</div>`;
        elements.aiDeck.appendChild(cardElement);
    });
}


        // Play Card
function playCard(cardIndex) {
    if (gameState.gameOver || gameState.currentTurn !== "player") return;
    console.log("Card clicked:", cardIndex, gameState.player.deck[cardIndex]);

    const player = gameState.player;
    const card = player.deck[cardIndex];
    
    if (!card) {
        console.error("Invalid card index:", cardIndex);
        return;
    }

    // Play sound based on card type
    if (card.name === "Crush") playCrushSound();
    else if (card.name === "Egg") playEggSound();   
    else if (card.name === "Fireball") playFireballSound();
    else if (card.type === "attack") playAttackSound();
    else if (card.type === "heal") playHealSound();
    else if (card.name === "Shield") playShieldSound();

    // Animation
    const cardElement = elements.playerDeck.children[cardIndex];
    cardElement.classList.add('card-play-anim');

    // Apply effect after animation
    setTimeout(() => {
        // Clear animation class
        cardElement.classList.remove('card-play-anim');

        if (gameState.isMultiplayer) {
            // Multiplayer logic
            socket.emit('playCard', {
                roomId: gameState.roomId,
                cardIndex: cardIndex
            });
            
            // Apply effects locally immediately for responsiveness
            const target = gameState.opponent;
            applyCardEffects(card, player, target);
            
            // Update UI immediately
            elements.aiHealthBar.style.width = `${target.health}%`;
            elements.aiHealthText.textContent = `${target.health}/100`;
            
            // Switch turns
            gameState.currentTurn = "opponent";
            updateUI();
        } else {
            // Single-player logic
            const ai = gameState.ai;
            applyCardEffects(card, player, ai);
            
            // Update AI health display immediately
            elements.aiHealthBar.style.width = `${ai.health}%`;
            elements.aiHealthText.textContent = `${ai.health}/100`;

            // Remove used card
            player.deck.splice(cardIndex, 1);

            // Draw new card if we have less than 5
            if (player.deck.length < 5) {
                const newCard = {...gameState.selectedCards[Math.floor(Math.random() * gameState.selectedCards.length)]};
                player.deck.push(newCard);
                
                // Animate the new card being drawn
                setTimeout(() => {
                    const newCardElement = createCardElement(newCard);
                    newCardElement.style.opacity = '0';
                    elements.playerDeck.appendChild(newCardElement);
                    
                    // Animate the card appearing
                    setTimeout(() => {
                        newCardElement.style.transition = 'opacity 0.5s';
                        newCardElement.style.opacity = '1';
                    }, 50);
                }, 300);
            }

            // Check if game is over
            if (ai.health <= 0 || player.health <= 0) {
                endGame();
                return;
            }

            // Check for extra turns from special move
            if (player.extraTurns && player.extraTurns > 0) {
                player.extraTurns--;
                addToLog(`${player.name} gets an extra turn!`);
                updateUI();
            } else {
                // Switch to AI turn
                gameState.currentTurn = "ai";
                updateUI();

                // AI moves after delay
                setTimeout(() => {
                    if (!gameState.gameOver) {
                        makeAIMove();
                    }
                }, 1000);
            }
        }
    }, 300);
}
function useSpecialMove() {
    // Validate conditions
    if (gameState.gameOver || 
        gameState.currentTurn !== "player" || 
        gameState.player.specialMoveUsed || 
        !gameState.player.specialMove) {
        return;
    }

    const player = gameState.player;
    const target = gameState.isMultiplayer ? gameState.opponent : gameState.ai;

    try {
        // Check if effect exists and is a function
        if (typeof player.specialMove.effect !== 'function') {
            throw new Error("Special move effect is not a function");
        }

        // Play appropriate sound effect
        if (player.specialMove.name.includes("Founder Dominance")) {
            playDominanceSound();
        } else if (player.specialMove.name.includes("Cat")) {
            playCatSound();
        } else if (player.specialMove.name.includes("Batman")) {
            playBatmanSound();
        } else if (player.specialMove.name.includes("Clown")) {
            playClownSound();
        } else if (player.specialMove.name.includes("Love")) {
            playLoveSound();
        } else if (player.specialMove.name.includes("Egg")) {
            playEggySound();
        } else if (player.specialMove.name.includes("Matrix")) {
            playMatrixSound();
        } else if (player.specialMove.name.includes("Dictator")) {
            playDictatorSound();
        } else if (player.specialMove.name.includes("Proofer") ||
                   player.specialMove.name.includes("Artiste") ||
                   player.specialMove.name.includes("Helper")) {
            playHealerSound();
        } else if (player.specialMove.name.includes("Simp")) {
            playSimpSound();
        } else {
            playSpecialSound();
        }

        // Mark special move as used
        player.specialMoveUsed = true;
        updateUI();

        // Show notification
        showNotification(`${player.specialMove.name} USED!`, 1500);

        // Apply the effect
        const message = player.specialMove.effect(player, target);
        addToLog(message);

        if (gameState.isMultiplayer) {
            // Multiplayer logic
            socket.emit('specialMoveUsed', {
                roomId: gameState.roomId,
                playerId: socket.id,
                moveName: player.specialMove.name
            });
        }

        // Update health displays
        updateUI();

        // Check for game over
        if (target.health <= 0 || player.health <= 0) {
            endGame();
            return;
        }

        // Handle special moves that grant extra turns
        const extraTurnMoves = ["Botman", "Queen", "Love Bomb", "Matrix Glitch"];
        const grantsExtraTurn = extraTurnMoves.includes(player.specialMove.name);
        
        if (!grantsExtraTurn) {
            // Standard behavior - switch turns
            setTimeout(() => {
                gameState.currentTurn = gameState.isMultiplayer ? "opponent" : "ai";
                updateUI();
                
                // If single-player and AI's turn, make AI move
                if (!gameState.isMultiplayer && !gameState.gameOver) {
                    setTimeout(() => makeAIMove(), 1000);
                }
            }, 500);
        } else {
            // Special moves that grant extra turns
            if (player.specialMove.name === "Matrix Glitch") {
                // Add visual effect to cards
                const cards = elements.playerDeck.querySelectorAll('.card');
                cards.forEach(card => {
                    card.classList.add('glitch-effect');
                    setTimeout(() => card.classList.remove('glitch-effect'), 1000);
                });
                player.nextAttackDoubled = true;
            }
            addToLog(`${player.name} gets to keep their turn!`);
        }

    } catch(error) {
        console.error("Error applying special move:", error);
        addToLog(`Failed to use ${gameState.player.specialMove.name}!`);
        return; // Exit the function if the effect fails
    }
}
// When receiving player data in multiplayer
function reconstructSpecialMove(specialMoveData) {
    // Create a new special move object
    const specialMove = {
        name: specialMoveData.name,
        description: specialMoveData.description
    };
    
    // Recreate the effect function based on the move name
    switch(specialMoveData.name) {
        case "Founder Dominance":
            specialMove.effect = (user, target) => {
                target.health -= 40;
                if (target.health < 0) target.health = 0;
                return `${user.name} uses Founder Dominance! Deals 40 damage to ${target.name}!`;
            };
            break;
        // Add cases for all your special moves...
        default:
            specialMove.effect = () => "Special move used!";
    }
    
    return specialMove;
}

        // AI Move
     function makeAIMove() {
        while (elements.aiDeck.children.length > 5) {
    elements.aiDeck.removeChild(elements.aiDeck.lastChild);
}
    if (gameState.gameOver || gameState.currentTurn !== "ai") {
        // Ensure panels are in correct state
        elements.gameContainer.style.display = 'flex';
        elements.characterSelect.style.display = 'none';
        return;
    }

    const ai = gameState.ai;
    const player = gameState.player;

    // 1. Special move check
    if (!ai.specialMoveUsed) {
        const shouldUseSpecial = 
            (ai.specialMove.name === "Botman" || 
             ai.specialMove.name === "Queen" || 
             ai.specialMove.name === "Love Bomb") ||
            (ai.health <= 50 && ai.specialMove.effect.toString().includes('user.health')) ||
            (player.health <= 50 && ai.specialMove.effect.toString().includes('target.health'));
        
        if (shouldUseSpecial) {
            useAISpecialMove();
            return;
        }
    }

    // 2. Improved card selection
    let cardIndex = 0;
    let selectedCard;
    
    // Get all card types
    const attacks = ai.deck.filter(card => card.type === "attack");
    const attack = ai.deck.filter(card=>card.name === "Egg");  
    const heals = ai.deck.filter(card => card.type === "heal");
    const shield = ai.deck.find(card => card.name === "Shield");

    // Decision logic
    if (ai.health <= 30) {
        // Priority 1: Heal when low
        if (heals.length > 0) {
            selectedCard = heals[0];
        } 
        // Priority 2: Strong attack
        else if (attacks.length > 0) {
            selectedCard = attacks.reduce((a, b) => a.power > b.power ? a : b);
        }
        // Priority 3: Shield only if high threat
        else if (shield) {
            selectedCard = shield;
        }
    } 
    else if (ai.health <= 60) {
        // Priority 1: Strong attack
        if (attacks.length > 0) {
            selectedCard = attacks.reduce((a, b) => a.power > b.power ? a : b);
        }
        // Priority 2: Shield
        else if (shield) {
            selectedCard = shield;
        }
    }
    else {
        // Always prefer attacks when healthy
        if (attacks.length > 0) {
            selectedCard = attacks.reduce((a, b) => a.power > b.power ? a : b);
        }
        // Shield only if no other options
        else if (shield) {
            selectedCard = shield;
        }
    }

    // Fallback to random card if no selection
    if (!selectedCard) {
        cardIndex = Math.floor(Math.random() * ai.deck.length);
        selectedCard = ai.deck[cardIndex];
    } else {
        cardIndex = ai.deck.findIndex(card => card === selectedCard);
    }

    // 3. Execute the move
    const cardElement = elements.aiDeck.children[cardIndex];
    
    // Play sound based on card type
    if (selectedCard.name === "Crush") {
        playCrushSound();
    } else if (selectedCard.name === "Egg") {
        playEggSound();
    } else if (selectedCard.type === "attack") {
        playAttackSound();
    } else if (selectedCard.type === "heal") {
        playHealSound();
    } else if (selectedCard.name === "Shield") {
        playShieldSound();
    }

    // Reveal card
    cardElement.innerHTML = `
        <div class="card-name">${selectedCard.name}</div>
        <div class="card-icon ${selectedCard.name === "Egg" ? "egg" : selectedCard.type}">${selectedCard.icon}</div>
        <div class="card-value">${selectedCard.name === "Shield" ? "Â½" : selectedCard.power}</div>
    `;
    cardElement.classList.add('card-play-anim');

    // Apply effects after animation
    setTimeout(() => {
        // Clear animation class
        cardElement.classList.remove('card-play-anim');

        if (selectedCard.type === "attack" || selectedCard.name === "Egg") {
            let damage = selectedCard.power;
            
            // Apply Matrix Glitch effect if active
           
            
            if (player.shieldActive) {
                damage = Math.max(1, Math.floor(damage / 2));
                addToLog(`${player.name}'s Shield reduces damage to ${damage}!`);
                player.shieldActive = false;
            }
            
            player.health -= damage;
            if (player.health < 0) player.health = 0;
            addToLog(`${ai.name} attacks with ${selectedCard.name} for ${damage} damage!`);
            
            // Update player health display immediately
            elements.playerHealthBar.style.width = `${player.health}%`;
            elements.playerHealthText.textContent = `${player.health}/100`;
        } 
        else if (selectedCard.type === "heal") {
            let healAmount = selectedCard.power;
            
            // Apply Matrix Glitch effect if active
            
            ai.health += healAmount;
            if (ai.health > 100) ai.health = 100;
            addToLog(`${ai.name} heals for ${healAmount} HP!`);
            
            // Update AI health display immediately
            elements.aiHealthBar.style.width = `${ai.health}%`;
            elements.aiHealthText.textContent = `${ai.health}/100`;
        }
        else if (selectedCard.name === "Shield") {
            ai.shieldActive = true;
            addToLog(`${ai.name} activates Shield! Next attack will be halved!`);
        }

        // Remove used card
        ai.deck.splice(cardIndex, 1);

        // Draw new card if we have less than 5
       if (ai.deck.length < 5) {
    const newCard = getRandomCard();
    ai.deck.push(newCard);
    
    // Only add to display if we're still under 5 cards
    if (elements.aiDeck.children.length < 5) {
        // Add the new card to AI deck (face down)
        setTimeout(() => {
            const newCardElement = document.createElement('div');
            newCardElement.className = 'card ai-card';
            newCardElement.innerHTML = `<div style="font-size: 2rem;">â“</div>`;
            newCardElement.style.opacity = '0';
            elements.aiDeck.appendChild(newCardElement);
            
            // Animate the card appearing
            setTimeout(() => {
                newCardElement.style.transition = 'opacity 0.5s';
                newCardElement.style.opacity = '1';
            }, 50);
        }, 300);
    }
}

        // Check game over
        if (player.health <= 0 || ai.health <= 0) {
            endGame();
            return;
        }

        // Decrement Matrix Glitch turns if active
       

        // Handle extra turns
        if (ai.extraTurns > 0) {
            ai.extraTurns--;
            addToLog(`${ai.name} gets an extra turn!`);
            setTimeout(() => makeAIMove(), 1000);
        } else {
            // Switch back to player
            gameState.currentTurn = "player";
            updateUI();
        }
    }, 300);
}
        // AI Special Move
        function useAISpecialMove() {
            const ai = gameState.ai;
            const player = gameState.player;

            playSpecialSound();

            // Mark special move as used
            ai.specialMoveUsed = true;
            
            // Show notification
            showNotification(`${ai.specialMove.name} USED!`, 500);
            
            // Apply special move effect
            const message = ai.specialMove.effect(ai, player);
            addToLog(message);
            
            // Check if game is over
            if (player.health <= 0 || ai.health <= 0) {
                endGame();
                return;
            }
            
            // Update UI
            updateUI();
            
            // If special move grants another turn, AI gets another move
            if (ai.specialMove.name === "Botman" || ai.specialMove.name === "Queen" || ai.specialMove.name === "Love Bomb") {
                setTimeout(() => {
                    if (!gameState.gameOver) {
                        makeAIMove();
                    }
                }, 1000);
            } else {
                // Switch back to player
                setTimeout(() => {
                    gameState.currentTurn = "player";
                    updateUI();
                }, 1000);
            }
        }

        // End Game
        function endGame() {
            gameState.gameOver = true;
            const player = gameState.player;
            const ai = gameState.ai;

             // Determine winner
    let winner;
    if (gameState.player.health <= 0 && (gameState.ai?.health <= 0 || gameState.opponent?.health <= 0)) {
        winner = "draw";
    } else if (gameState.player.health <= 0) {
        winner = "opponent";
    } else {
        winner = "player";
    }
    
    if (gameState.isMultiplayer) {
        socket.emit('gameOver', {
            roomId: gameState.roomId,
            winner: winner === "player" ? socket.id : (winner === "opponent" ? gameState.opponent.socketId : null)
        });
    }

            // Force health bars to update to 0 if needed
            if (player.health <= 0) {
                player.health = 0;
                elements.playerHealthBar.style.width = '0%';
                elements.playerHealthText.textContent = '0/100';
            }
            if (ai.health <= 0) {
                ai.health = 0;
                elements.aiHealthBar.style.width = '0%';
                elements.aiHealthText.textContent = '0/100';
            }

            // Clear any existing effects
            document.querySelectorAll('.victory-effect, .defeat-effect, .draw-effect').forEach(el => el.remove());

            let winnerMessage = "";
            let effect = null;
            
            if (player.health <= 0 && ai.health <= 0) {
                winnerMessage = "DRAW!";
                addToLog("The battle ends in a draw!");
                effect = createEffect('draw');
            } else if (player.health <= 0) {
                winnerMessage = `${ai.name} WINS!`;
                addToLog(`${ai.name} wins the battle!`);
                effect = createEffect('defeat');
                playDefeatSound();
            } else {
                winnerMessage = `${player.name} WINS!`;
                addToLog(`${player.name} wins the battle!`);
                effect = createEffect('victory');
                playVictorySound();
            }

            // Show effect and notification
            document.body.appendChild(effect);
            showNotification(winnerMessage);
            elements.turnIndicator.style.display = 'none';

            // Disable all game controls
            document.querySelectorAll('.card').forEach(card => {
                card.style.pointerEvents = 'none';
            });
            elements.specialMoveBtn.disabled = true;
            
            // Force UI update
            updateUI();
        }

        // Helper function to create effects
        function createEffect(type) {
            const effect = document.createElement('div');
            effect.className = `${type}-effect`;
            
            // Remove effect after animation completes
            setTimeout(() => {
                effect.remove();
            }, 3000);
            
            return effect;
        }

        // Add to Battle Log
        function addToLog(message) {
            const logEntry = document.createElement('div');
            logEntry.className = 'log-entry';
            logEntry.textContent = `> ${message}`;
            elements.battleLog.appendChild(logEntry);
            elements.battleLog.scrollTop = elements.battleLog.scrollHeight;
        }

        function restartMatch() {
    if (!gameState.player || !gameState.ai) return;
    
    // Reset health and game state
    gameState.player.health = 100;
    gameState.ai.health = 100;
    gameState.currentTurn = "player";
    gameState.gameOver = false;
    gameState.player.specialMoveUsed = false;
    gameState.ai.specialMoveUsed = false;
    gameState.player.extraTurns = 0;
    gameState.ai.extraTurns = 0;
    gameState.player.nextAttackDoubled = false;
    // Reset decks to original state
    gameState.player.deck = [...gameState.selectedCards];
    gameState.ai.deck = generateRandomDeck();
    
    // Clear battle log
    elements.battleLog.innerHTML = '<div class="log-entry">Match restarted!</div>';
    
    // Update UI
    updateUI();
    addToLog(`Match restarted: ${gameState.player.name} vs ${gameState.ai.name}`);
    addToLog(`Player goes first!`);
    
    // Clear any existing effects
    document.querySelectorAll('.victory-effect, .defeat-effect, .draw-effect').forEach(el => el.remove());
}

        // New Game
        function newGame() {
             elements.mainMenu.style.display = 'flex';
    elements.gameContainer.style.display = 'none';
    elements.characterSelect.style.display = 'none';
             // Stop background music
    document.getElementById('bg-music').pause();
    document.getElementById('bg-music').currentTime = 0;
    
    // Remove play button if it exists
    const playButton = document.getElementById('music-play-btn');
    if (playButton) playButton.remove();

     // Clear battle log - ADD THIS LINE
    elements.battleLog.innerHTML = '<div class="log-entry">System initialized. Battle ready.</div>';
            // Hide game UI
            elements.gameContainer.style.display = 'none';
            
            // Show character selection
            elements.characterSelect.style.display = 'flex';
            elements.deckBuilder.style.display = 'none';
            
            // Reset game state
            gameState.selectedCards = [];
            gameState.player = null;
            gameState.ai = null;
            
            // Reinitialize character selection
            initCharacterSelection();
        }

        // Event Listeners
        elements.startGameBtn.addEventListener('click', startGame);
        elements.newGameBtn.addEventListener('click', newGame);
        elements.restartBtn.addEventListener('click', restartMatch);
        elements.specialMoveBtn.addEventListener('click', useSpecialMove);
       // Main Menu Event Listeners
    elements.normalModeBtn.addEventListener('click', () => {
        elements.mainMenu.style.display = 'none';
        elements.characterSelect.style.display = 'flex';
    });

    // Add this with your other event listeners
elements.multiplayerBtn.addEventListener('click', () => {
    if (gameState.selectedCards.length === 5) {
        elements.characterSelect.style.display = 'none';
        elements.multiplayerMenu.style.display = 'flex';
    } else {
        alert("Please select exactly 5 cards first!");
    }
});

    elements.quitBtn.addEventListener('click', () => {
        if (confirm("Are you sure you want to quit?")) {
            window.close();
            window.location.href = "about:blank";
        }
    });

        // Initialize Game - Hide all screens except main menu
elements.mainMenu.style.display = 'flex';
elements.characterSelect.style.display = 'none';
elements.gameContainer.style.display = 'none';
initCharacterSelection();
    </script>
</body>
</html>

