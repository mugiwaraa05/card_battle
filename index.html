<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Succinct Card Battle</title>
    <style>
        :root {
            --neon-pink: #ff2a6d;
            --neon-blue: #05d9e8;
            --neon-purple: #d300c5;
            --dark-bg: #0d0221;
            --darker-bg: #05010e;
            --card-width: 120px;
            --card-height: 180px;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
            font-family: 'Courier New', monospace;
        }

        body {
            background-color: var(--dark-bg);
            color: white;
            min-height: 100vh;
            position: relative;
            background-image: 
                radial-gradient(circle at 20% 30%, rgba(255, 42, 109, 0.15) 0%, transparent 25%),
                radial-gradient(circle at 80% 70%, rgba(5, 217, 232, 0.15) 0%, transparent 25%);
        }

        /* Main container */
        .game-container {
            display: flex;
            min-height: 100vh;
            position: relative;
        }

        /* Character selection screen */
        .character-select {
            position: relative;
            width: 100%;
            min-height: 100vh;
            background-color: var(--darker-bg);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            padding: 20px;
            text-align: center;
            overflow-y: auto;
        }

        .character-select h1 {
            color: var(--neon-pink);
            text-shadow: 0 0 10px var(--neon-pink);
            margin: 20px 0;
            font-size: 2.5rem;
        }

        .character-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 20px;
            max-width: 800px;
            margin-bottom: 30px;
            width: 100%;
        }

        .character-card {
            background: rgba(13, 2, 33, 0.7);
            border: 2px solid var(--neon-blue);
            border-radius: 10px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
        }

        .character-card.selected {
            border-color: var(--neon-pink);
            box-shadow: 0 0 20px var(--neon-pink);
            transform: scale(1.05);
        }

        .character-avatar {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            object-fit: cover;
            border: 2px solid var(--neon-purple);
            margin-bottom: 10px;
        }

        .character-name {
            color: var(--neon-blue);
            font-weight: bold;
            margin-top: 5px;
        }

        .special-move-info {
            display: none;
            background: rgba(5, 1, 14, 0.9);
            border: 1px solid var(--neon-pink);
            border-radius: 10px;
            padding: 10px;
            margin-top: 10px;
            width: 100%;
            text-align: center;
        }

        .character-card.selected .special-move-info {
            display: block;
            animation: fadeIn 0.3s ease;
        }

        .special-move-name {
            color: var(--neon-pink);
            font-weight: bold;
            margin-bottom: 5px;
        }

        /* Deck builder */
        .deck-builder {
            background: rgba(5, 1, 14, 0.9);
            border: 1px solid var(--neon-purple);
            border-radius: 10px;
            padding: 20px;
            max-width: 600px;
            margin: 20px 0;
            width: 100%;
        }

        .deck-builder h2 {
            color: var(--neon-blue);
            margin-bottom: 15px;
            text-align: center;
        }

        .card-options {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
        }

        .card-option {
            background: rgba(13, 2, 33, 0.7);
            border: 1px solid var(--neon-blue);
            border-radius: 5px;
            padding: 10px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
        }

        .card-option:hover {
            border-color: var(--neon-pink);
        }

        .card-option.selected {
            border-color: var(--neon-pink);
            box-shadow: 0 0 10px var(--neon-pink);
        }

        .start-game-btn {
            background: linear-gradient(45deg, var(--neon-pink), var(--neon-purple));
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 30px;
            font-size: 1.2rem;
            font-weight: bold;
            margin: 30px 0;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 0 15px var(--neon-purple);
        }

        .start-game-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 25px var(--neon-pink);
        }

        /* Battle UI */
        .battle-ui {
            display: flex;
            flex-direction: column;
            width: 100%;
            min-height: 100vh;
            padding: 20px;
            position: relative;
        }

        /* Player areas */
        .player-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            position: relative;
            min-height: 50vh;
        }

        .player-info {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 15px;
        }

        .battle-avatar {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            object-fit: cover;
            border: 2px solid var(--neon-blue);
            box-shadow: 0 0 10px var(--neon-blue);
        }

        .player-name {
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--neon-blue);
            text-shadow: 0 0 5px var(--neon-blue);
        }

        .health-container {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .health-bar {
            height: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            flex: 1;
            overflow: hidden;
        }

        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff2a6d, #ff7b00);
            width: 100%;
            transition: width 0.3s ease;
        }

        .health-text {
            min-width: 80px;
            text-align: center;
            font-weight: bold;
            color: white;
        }

        /* Card decks */
        .deck-area {
            display: flex;
            justify-content: center;
            gap: 15px;
            height: calc(var(--card-height) + 30px);
            align-items: center;
            flex-wrap: wrap;
            margin: 10px 0;
        }

        .card {
            width: var(--card-width);
            height: var(--card-height);
            background: linear-gradient(145deg, #1a1a2e, #2a2a4e);
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 15px;
            color: white;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
            position: relative;
            cursor: pointer;
            transition: all 0.3s;
            border: 1px solid var(--neon-blue);
            overflow: hidden;
        }

        .card::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: linear-gradient(45deg, var(--neon-blue), var(--neon-purple), var(--neon-pink));
            z-index: -1;
            border-radius: 12px;
            opacity: 0.7;
        }

        .card:hover {
            transform: translateY(-10px) scale(1.05);
            box-shadow: 0 10px 25px rgba(255, 42, 109, 0.5);
            border-color: var(--neon-pink);
        }

        .card.ai-card {
            background: linear-gradient(145deg, #2a2a4e, #3a3a6e);
            cursor: not-allowed;
        }

        .card.ai-card::before {
            background: linear-gradient(45deg, #555, #888);
        }

        .card-name {
            font-weight: bold;
            text-align: center;
            font-size: 1.1rem;
            margin-bottom: 5px;
            color: var(--neon-blue);
        }

        .card-icon {
            font-size: 3rem;
            text-align: center;
            margin: 10px 0;
            text-shadow: 0 0 10px currentColor;
        }

        .card.attack .card-icon {
            color: var(--neon-pink);
        }

        .card.heal .card-icon {
            color: #00ff9d;
        }

        .card-value {
            font-size: 1.5rem;
            font-weight: bold;
            text-align: center;
        }

        .card.attack .card-value {
            color: var(--neon-pink);
            text-shadow: 0 0 5px var(--neon-pink);
        }

        .card.heal .card-value {
            color: #00ff9d;
            text-shadow: 0 0 5px #00ff9d;
        }

        /* Special move button */
        .special-move-btn {
            background: linear-gradient(45deg, var(--neon-purple), var(--neon-pink));
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 20px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            margin-top: 10px;
            box-shadow: 0 0 10px var(--neon-purple);
        }

        .special-move-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 15px var(--neon-pink);
        }

        .special-move-btn:disabled {
            background: #555;
            color: #999;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }

        /* Battle log */
        .battle-log {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 350px;
            height: 200px;
            background-color: rgba(0, 0, 0, 0.7);
            border: 1px solid var(--neon-blue);
            border-radius: 5px;
            padding: 10px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            color: #00ff9d;
            box-shadow: 0 0 15px rgba(5, 217, 232, 0.3);
            z-index: 10;
        }

        .battle-log::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 30px;
            background: linear-gradient(to bottom, rgba(5, 217, 232, 0.3), transparent);
            pointer-events: none;
        }

        .log-entry {
            margin-bottom: 5px;
            padding-bottom: 5px;
            border-bottom: 1px solid rgba(5, 217, 232, 0.2);
            animation: fadeIn 0.3s ease;
        }

        /* Notification */
        .notification {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: var(--neon-pink);
            padding: 15px 30px;
            border-radius: 30px;
            font-size: 1.5rem;
            font-weight: bold;
            text-shadow: 0 0 10px var(--neon-pink);
            z-index: 100;
            animation: fadeInOut 5s ease forwards;
            background: transparent;
        }

        @keyframes fadeInOut {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
            20% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
            80% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
        }

        /* Turn indicator */
        .turn-indicator {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(45deg, var(--neon-pink), var(--neon-purple));
            color: white;
            padding: 8px 20px;
            border-radius: 20px;
            font-weight: bold;
            box-shadow: 0 0 15px var(--neon-purple);
            z-index: 10;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 10px var(--neon-purple); }
            50% { box-shadow: 0 0 20px var(--neon-pink); }
            100% { box-shadow: 0 0 10px var(--neon-purple); }
        }

        /* Effects */
        .damage-effect {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, rgba(255, 42, 109, 0.5) 0%, transparent 70%);
            animation: flash 0.5s;
        }

        .heal-effect {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, rgba(0, 255, 157, 0.5) 0%, transparent 70%);
            animation: flash 0.5s;
        }

        /* Victory/Defeat Effects */
        .victory-effect {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, rgba(0,255,157,0.7) 0%, transparent 70%);
            animation: fadeIn 1s ease forwards;
            z-index: 50;
            pointer-events: none;
        }

        .defeat-effect {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, rgba(255,42,109,0.7) 0%, rgba(13,2,33,0.9) 70%);
            animation: fadeIn 1s ease forwards;
            z-index: 50;
            pointer-events: none;
        }

        .draw-effect {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, rgba(5,217,232,0.7) 0%, rgba(13,2,33,0.9) 70%);
            animation: fadeIn 1s ease forwards;
            z-index: 50;
            pointer-events: none;
        }

        @keyframes flash {
            0% { opacity: 0; transform: scale(0.5); }
            50% { opacity: 1; transform: scale(1.1); }
            100% { opacity: 0; transform: scale(1); }
        }

        /* Controls */
        .controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            padding: 15px;
            margin-top: auto;
        }

        .control-btn {
            background: linear-gradient(45deg, var(--neon-blue), var(--neon-purple));
            color: white;
            border: none;
            padding: 10px 25px;
            border-radius: 25px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
            box-shadow: 0 0 10px var(--neon-blue);
        }

        .control-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 0 15px var(--neon-pink);
        }

        .control-btn:disabled {
            background: #555;
            color: #999;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }

        /* Animations */
        .card-play-anim {
            animation: cardPlay 0.5s ease forwards;
        }

        @keyframes cardPlay {
            0% { transform: translateY(0) scale(1); }
            50% { transform: translateY(-50px) scale(1.1); }
            100% { transform: translateY(0) scale(1); }
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(5px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Responsive Styles */
        @media (max-width: 768px) {
            :root {
                --card-width: 80px;
                --card-height: 120px;
            }

            .character-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 15px;
            }

            .card-options {
                grid-template-columns: repeat(2, 1fr);
            }

            .battle-log {
                width: calc(100% - 40px);
                height: 120px;
                bottom: 100px;
                left: 20px;
                right: 20px;
            }

            .player-info {
                flex-wrap: wrap;
            }

            .health-container {
                width: 100%;
                order: 3;
                margin-top: 10px;
            }

            .player-name {
                font-size: 1.2rem;
            }

            .battle-avatar {
                width: 40px;
                height: 40px;
            }

            .card {
                padding: 5px;
            }

            .card-name {
                font-size: 0.7rem;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
            }

            .card-icon {
                font-size: 1.5rem;
                margin: 5px 0;
            }

            .card-value {
                font-size: 1rem;
            }

            .deck-area {
                height: auto;
                min-height: calc(var(--card-height) + 20px);
                padding: 5px 0;
                gap: 8px;
                margin: 10px 0;
            }

            .special-move-btn {
                position: relative;
                width: 80%;
                max-width: 250px;
                margin: 10px auto;
                padding: 10px 20px;
                font-size: 1rem;
                background: linear-gradient(45deg, var(--neon-purple), var(--neon-pink));
                border: 1px solid var(--neon-pink);
                box-shadow: 0 0 15px rgba(210, 0, 197, 0.7);
                text-shadow: 0 0 5px rgba(0,0,0,0.5);
                order: 1;
            }

            .controls {
                flex-direction: column;
                gap: 10px;
                position: fixed;
                bottom: 10px;
                left: 0;
                right: 0;
                background: rgba(5, 1, 14, 0.9);
                padding: 10px;
                z-index: 10;
            }

            .control-btn {
                padding: 8px 15px;
            }

            .player-area {
                display: flex;
                flex-direction: column;
                padding-bottom: 80px;
            }

            .player-area > .player-info {
                order: 0;
            }
            .player-area > .deck-area {
                order: 1;
            }
            .player-area > .special-move-btn {
                order: 2;
            }

            .turn-indicator {
                font-size: 0.9rem;
                padding: 5px 15px;
                top: 10px;
            }

            .special-move-info {
                font-size: 0.7rem;
                padding: 5px;
            }

            .notification {
                font-size: 1.2rem;
                padding: 10px 20px;
            }
        }

        @media (max-width: 480px) {
            :root {
                --card-width: 70px;
                --card-height: 100px;
            }

            .character-select h1 {
                font-size: 1.8rem;
            }

            .character-avatar {
                width: 60px;
                height: 60px;
            }

            .character-name {
                font-size: 0.9rem;
            }

            .deck-builder h2 {
                font-size: 1.2rem;
            }

            .start-game-btn {
                padding: 10px 20px;
                font-size: 1rem;
            }

            .battle-log {
                height: 100px;
                font-size: 0.8rem;
            }

            .card {
                padding: 3px;
            }

            .card-name {
                font-size: 0.6rem;
            }

            .card-icon {
                font-size: 1.2rem;
            }

            .card-value {
                font-size: 0.8rem;
            }

            .deck-area {
                gap: 5px;
            }

            .special-move-btn {
                padding: 8px 15px;
                font-size: 0.9rem;
            }

            .notification {
                font-size: 1rem;
                padding: 8px 15px;
            }
        }
      /* Add to your CSS */
@keyframes shuffleDeck {
    0% { transform: translateY(0) rotate(0deg); }
    25% { transform: translateY(-20px) rotate(-5deg); }
    50% { transform: translateY(0) rotate(0deg); }
    75% { transform: translateY(-20px) rotate(5deg); }
    100% { transform: translateY(0) rotate(0deg); }
}

@keyframes dealCard {
    0% {
        transform: translate(-50%, -50%) rotateY(0deg) scale(0.8);
        opacity: 0;
        z-index: 10;
    }
    20% {
        opacity: 1;
        transform: translate(-50%, -50%) rotateY(180deg) scale(1);
    }
    100% {
        transform: translate(0, 0) rotateY(0deg) scale(1);
        opacity: 1;
        z-index: 1;
    }
}

@keyframes dealAICard {
    0% {
        transform: translate(-50%, -50%) rotateY(0deg) scale(0.8);
        opacity: 0;
        z-index: 10;
    }
    20% {
        opacity: 1;
        transform: translate(-50%, -50%) rotateY(180deg) scale(1);
    }
    100% {
        transform: translate(0, 0) rotateY(180deg) scale(1);
        opacity: 1;
        z-index: 1;
    }
}

.deck-shuffle {
    animation: shuffleDeck 0.5s ease-in-out 3;
}

.card-deal-animation {
    position: absolute;
    top: 50%;
    left: 50%;
    animation: dealCard 0.8s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
    transform-origin: center;
}

.ai-card-deal-animation {
    position: absolute;
    top: 50%;
    left: 50%;
    animation: dealAICard 0.8s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
    transform-origin: center;
}

.deck-placeholder {
    position: relative;
    width: var(--card-width);
    height: var(--card-height);
    background: rgba(255, 255, 255, 0.1);
    border-radius: 10px;
    margin: 0 5px;
    box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
    display: flex;
    justify-content: center;
    align-items: center;
    color: rgba(255, 255, 255, 0.3);
    font-size: 2rem;
}
#music-play-btn {
    background: linear-gradient(45deg, var(--neon-pink), var(--neon-purple));
    color: white;
    border: none;
    padding: 8px 15px;
    border-radius: 20px;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.3s;
    box-shadow: 0 0 10px var(--neon-purple);
    z-index: 1000;
}

#music-play-btn:hover {
    transform: scale(1.05);
    box-shadow: 0 0 15px var(--neon-pink);
} 
/* Main Menu Styles */
.main-menu {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center; /* Ensures vertical centering */
    width: 100%;
    min-height: 100vh; /* Ensures full viewport height coverage */
    padding: 20px; /* Prevents content from touching edges */
    box-sizing: border-box; /* Ensures padding doesn't affect width */
    text-align: center; /* Centers text for all child elements */
}

.main-menu h1 {
    color: var(--neon-pink);
    text-shadow: 0 0 10px var(--neon-pink);
    margin-bottom: 50px;
    font-size: 3rem;
    text-align: center;
}

.menu-options {
    display: flex;
    flex-direction: column;
    gap: 20px;
    width: 100%; /* Takes full width on mobile */
    max-width: 300px; /* Limits width on larger screens */
    align-items: center; /* Ensures buttons stay centered */
}

.menu-btn {
    background: linear-gradient(45deg, var(--neon-blue), var(--neon-purple));
    color: white;
    border: none;
    padding: 15px 30px;
    border-radius: 30px;
    font-size: 1.2rem;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.3s;
    box-shadow: 0 0 15px var(--neon-blue);
    text-align: center;
}

.menu-btn:hover {
    transform: scale(1.05);
    box-shadow: 0 0 25px var(--neon-pink);
}

@media (max-width: 768px) {
    .main-menu h1 {
        font-size: 2rem;
    }
    .menu-options {
        width: 250px;
    }
    .menu-btn {
        padding: 12px 25px;
        font-size: 1rem;
    }
}   
/* Add this to your existing media queries section */
@media (max-width: 768px) {
    .main-menu {
        padding: 15px;
        text-align: center;
    }

    .main-menu h1 {
        font-size: 2rem;
        margin-bottom: 30px;
    }

    .menu-options {
        width: 100%;
        max-width: 280px;
    }

    .menu-btn {
        padding: 12px 20px;
        font-size: 1rem;
    }
}

@media (max-width: 480px) {
    .main-menu h1 {
        font-size: 1.8rem;
        margin-bottom: 20px;
    }

    .menu-btn {
        padding: 10px 15px;
        font-size: 0.9rem;
    }
} 
.multiplayer-menu {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100vh;
  background: var(--darker-bg);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 1000;
}

#join-room-input {
  margin-top: 20px;
  display: flex;
  gap: 10px;
}

#join-room-input input {
  padding: 10px;
  border: 2px solid var(--neon-blue);
  background: var(--dark-bg);
  color: white;
  border-radius: 5px;
}
.deck-builder-buttons {
    display: flex;
    gap: 15px;
    justify-content: center;
    margin-top: 20px;
}

.multiplayer-btn {
    background: linear-gradient(45deg, var(--neon-blue), var(--neon-purple));
}
    </style>
</head>
<!-- Add this in the head section after the styles -->
<audio id="attack-sound" src="./sounds/slash.wav" preload="auto"></audio>
<audio id="fireball-sound" src="./sounds/fire.wav" preload="auto"></audio>
<audio id="crush-sound" src="./sounds/crush.wav" preload="auto"></audio>
<audio id="egg-sound" src="./sounds/egg.ogg" preload="auto"></audio>
<audio id="heal-sound" src="./sounds/heal.wav" preload="auto"></audio>
<audio id="special-sound" src="./sounds/special.wav" preload="auto"></audio>
<audio id="shield-sound" src="./sounds/shield.wav" preload="auto"></audio>
<audio id="victory-sound" src="./sounds/victory.mp3" preload="auto"></audio>
<audio id="defeat-sound" src="./sounds/defeat.wav" preload="auto"></audio>
<audio id="draw-sound" src="./sounds/draw.wav" preload="auto"></audio>
<audio id="dominance-sound" src="./sounds/dominance.mp3" preload="auto"></audio>
<audio id="cat-sound" src="./sounds/cat.mp3" preload="auto"></audio>
<audio id="clown-sound" src="./sounds/clown.mp3" preload="auto"></audio>
<audio id="batman-sound" src="./sounds/batman.mp3" preload="auto"></audio>
<audio id="love-sound" src="./sounds/love.mp3" preload="auto"></audio>
<audio id="eggy-sound" src="./sounds/egg.mp3" preload="auto"></audio>
<audio id="healer-sound" src="./sounds/healer.mp3" preload="auto"></audio>
<audio id="simp-sound" src="./sounds/simp.mp3" preload="auto"></audio>
<audio id="matrix-sound" src="./sounds/matrix.mp3" preload="auto"></audio>
<audio id="dictator-sound" src="./sounds/dictator.mp3" preload="auto"></audio>
<audio id="bg-music" loop>
  <source src="./sounds/battle.mp3" type="audio/mpeg">
  Play Music
</audio>
<body>
     <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
<script>
  
</script>
    <!-- Main Menu Screen -->
<div class="main-menu" id="main-menu">
    <h1>SUCCINCT CARD BATTLE</h1>
    <div class="menu-options">
        <button class="menu-btn" id="normal-mode-btn">START GAME</button>
        <button class="menu-btn" id="quit-btn">QUIT</button>
    </div>
</div>
    <!-- Character Selection Screen -->
    <div class="character-select" id="character-select">
        <h1>SELECT YOUR FIGHTER</h1>
        <div class="character-grid" id="character-grid">
            <!-- Characters will be added here by JS -->
        </div>
        <div class="deck-builder" id="deck-builder" style="display: none;">
            <h2>BUILD YOUR DECK</h2>
            <div class="card-options" id="card-options">
                <!-- Card options will be added here by JS -->
            </div>
        <button class="start-game-btn" id="start-game-btn">PLAY VS AI</button>
        <button class="start-game-btn multiplayer-btn" id="multiplayer-btn">PLAY MULTIPLAYER
        </div>
    </div>
    <!-- Add after character-select div -->
<div class="multiplayer-menu" id="multiplayer-menu" style="display:none;">
  <h1>MULTIPLAYER</h1>
  <div class="menu-options">
    <button id="create-room-btn">CREATE ROOM</button>
    <button id="join-room-btn">JOIN ROOM</button>
    <div id="join-room-input" style="display:none;">
      <input type="text" id="room-code" placeholder="Enter Room Code">
      <button id="submit-room-code">JOIN</button>
    </div>
    <div id="waiting-area" style="display:none;">
      <p>Room Code: <span id="room-code-display"></span></p>
      <p>Waiting for player...</p>
    </div>
  </div>
</div>

    <!-- Main Game UI -->
    <div class="game-container" id="game-container" style="display: none;">
        <div class="battle-ui">
             <!-- Player (Bottom) -->
            <div class="player-area">
                <div class="player-info">
                    <img class="battle-avatar" id="player-avatar" src="" alt="Player Avatar">
                    <div class="player-name" id="player-name">PLAYER</div>
                    <div class="health-container">
                        <div class="health-bar">
                            <div class="health-fill" id="player-health-bar"></div>
                        </div>
                        <div class="health-text" id="player-health-text">100/100</div>
                    </div>
                </div>
                <div class="deck-area" id="player-deck">
                <div class="deck-placeholder">âœ§</div>
                    <!-- Player cards will be added here -->
                </div>
                <button class="special-move-btn" id="special-move-btn" disabled>USE SPECIAL MOVE</button>
            </div>
            <!-- AI Player (Top) -->
            <div class="player-area">
                <div class="turn-indicator" id="turn-indicator">YOUR TURN</div>
                <div class="player-info">
                    <img class="battle-avatar" id="ai-avatar" src="" alt="AI Avatar">
                    <div class="player-name" id="ai-name">AI</div>
                    <div class="health-container">
                        <div class="health-bar">
                            <div class="health-fill" id="ai-health-bar"></div>
                        </div>
                        <div class="health-text" id="ai-health-text">100/100</div>
                    </div>
                </div>
                <div class="deck-area" id="ai-deck">
                     <div class="deck-placeholder">âœ§</div>
                    <!-- AI cards will be added here -->
                </div>
            </div>

            <!-- Battle Log -->
            <div class="battle-log" id="battle-log">
                <div class="log-entry">System initialized. Battle ready.</div>
            </div>

            <!-- Controls -->
            <div class="controls">
                <button class="control-btn" id="new-game-btn">NEW GAME</button>
                <button class="control-btn" id="restart-btn">RESTART MATCH</button>
            </div>
        </div>
    </div>
<script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <script>
        // Game Data
        const characters = [
            { 
                name: "Uma", 
                avatar: "./Avatars/Uma.webp",
                specialMove: {
                    name: "Founder Dominance",
                    description: "Deals 40 damage to opponent",
                    effect: function (user, target)  {
                        target.health -= 40;
                        if (target.health < 0) target.health = 0;
                        return `${user.name} uses Founder Dominance! Deals 40 damage to ${target.name}!`;
                    }
                }
            },
            { 
                name: "Zahar0n", 
                avatar: "./Avatars/Zahar0n.webp",
                specialMove: {
                    name: "I am Batman",
                    description: "Deals 25 damage to opponent",
                    effect: function (user, target) {
                        target.health -= 25;
                        if (target.health < 0) target.health = 0;
                        return `${user.name} uses I am Batman! Deals 25 damage to ${target.name}!`;
                    }
                }
            },
            { 
                name: "Saigon", 
                avatar: "./Avatars/Saigon.jpg",
                specialMove: {
                    name: "Cat Attack",
                    description: "Deals 20 damage to opponent",
                    effect: function (user, target)  {
                        target.health -= 20;
                        if (target.health < 0) target.health = 0;
                        return `${user.name} uses Cat Attack! Deals 20 damage to ${target.name}!`;
                    }
                }
            },
            { 
                name: "Yinger", 
                avatar: "./Avatars/Yinger.webp",
                specialMove: {
                    name: "Dictator",
                    description: "Deals 35 damage to opponent",
                    effect: function (user, target)  {
                        target.health -= 35;
                        if (target.health < 0) target.health = 0;
                        return `${user.name} uses Dictator! Deals 35 damage to ${target.name}!`;
                    }
                }
            },
            { 
                name: "Addy", 
                avatar: "./Avatars/Addy.webp",
                specialMove: {
                    name: "Eggscalibur",
                    description: "Deals 30 damage to opponent",
                    effect: function (user, target)  {
                        target.health -= 30;
                        if (target.health < 0) target.health = 0;
                        return `${user.name} uses Eggscalibur! Deals 30 damage to ${target.name}!`;
                    }
                }
            },
            { 
                name: "Stepaks", 
                avatar: "./Avatars/Stepaks.webp",
                specialMove: {
                    name: "Botman",
                    description: "Gets one additional turn",
                    effect: function (user, target)  {
                        user.extraTurns = 1;
                        return `${user.name} uses Botman! Gets one additional turn!`;
                    }
                }
            },
            { 
                name: "Pix", 
                avatar: "./Avatars/Pix.webp",
                specialMove: {
                    name: "Artiste",
                    description: "Heals 40 HP",
                    effect: function (user, target) {
                        user.health += 40;
                        if (user.health > 100) user.health = 100;
                        return `${user.name} uses Artiste! Heals 40 HP!`;
                    }
                }
            },
            { 
                name: "Cocowaves", 
                avatar: "./Avatars/Cocowaves.jpg",
                specialMove: {
                    name: "Queen",
                    description: "Gets one additional turn",
                    effect: function (user, target) {
                        user.extraTurns = 1;
                        return `${user.name} uses Queen! Gets one additional turn!`;
                    }
                }
            },
            { 
                name: "Zkdan", 
                avatar: "./Avatars/dan.webp",
                specialMove: {
                    name: "Labubu Rage",
                    description: "Deals 40 damage to opponent",
                    effect: function (user, target)  {
                        target.health -= 40;
                        if (target.health < 0) target.health = 0;
                        return `${user.name} uses Labubu Rage! Deals 40 damage to ${target.name}!`;
                    }
                }
            },
            { 
                name: "Bugs", 
                avatar: "./Avatars/Bugs.webp",
                specialMove: {
                    name: "Mr Helper",
                    description: "Heals 30 HP",
                    effect:function (user, target) {
                        user.health += 30;
                        if (user.health > 100) user.health = 100;
                        return `${user.name} uses Mr Helper! Heals 30 HP!`;
                    }
                }
            },
            { 
                name: "Tuong", 
                avatar: "./Avatars/Tuong.webp",
                specialMove: {
                    name: "Mr Green",
                    description: "Heals 25 HP",
                    effect: function (user, target) {
                        user.health += 25;
                        if (user.health > 100) user.health = 100;
                        return `${user.name} uses Mr Green! Heals 25 HP!`;
                    }
                }
            },
            { 
                name: "Chixxey", 
                avatar: "./Avatars/Chixxey.webp", 
                specialMove: {
                    name: "Love Bomb",
                    description: "Deals 5 damage to opponent and gets an extra turn",
                    effect: function (user, target) {
                        target.health -= 5;
                        if (target.health < 0) target.health = 0;
                        user.extraTurns = 1;
                        return `${user.name} uses Love Bomb! Deals 5 damage to ${target.name} and gets an extra turn!`;
                    }
                }
            },

            
            { 
                name: "Wylo", 
                avatar: "./Avatars/Wylo.jpg",
                specialMove: {
                    name: "The Clown",
                    description: "Deals 35 damage to himself",
                    effect: function (user, target)  {
                        user.health -= 35;
                        if (user.health < 0) user.health = 0;
                        return `${user.name} uses The Clown! Deals 35 damage to himself!`;
                    }
                }
            },

          { 
    name: "Serkan", 
    avatar: "./Avatars/Serkan.jpg",
    specialMove: {
        name: "Matrix Glitch",
        description: "His next attack deals double damage",
        effect: function (user, target) {
            // Set flag for next attack
            user.nextAttackDoubled = true;
            return `${user.name} uses Matrix Glitch! Next attack will deal double damage!`;
        }
    }
},
    { 
        name: "Jekyde", 
        avatar: "./Avatars/Jekyde.jpg",
        specialMove: {
            name: "Mr Shipper",
            description: "+20 HP to himself and -20 HP to opponent",
            effect: function (user, target) {
                // Heal user
                user.health += 20;
                if (user.health > 100) user.health = 100;
                
                // Damage opponent
                target.health -= 20;
                if (target.health < 0) target.health = 0;
                
                return `${user.name} uses Mr Shipper! +20 HP to himself and -20 HP to ${target.name}!`;
            }
        }
    },
    { 
        name: "ZkTug", 
        avatar: "./Avatars/Tug.jpg",
        specialMove: {
            name: "Proofer Regen",
            description: "Heals 40 HP ",
            effect: function (user, target) {
                user.health += 40;
                if (user.health > 100) user.health = 100;
                return `${user.name} uses Proofer Regen! +40 HP!`;
            }
        }
    },
   { 
    name: "Shoeb", 
    avatar: "./Avatars/Shoeb.jpg",
    specialMove: {
        name: "The Don",
        description: "Deals 30 damage to opponent and 10 damage to himself",
        effect: function (user, target) {
            target.health -= 30;
            if (target.health < 0) target.health = 0;
            user.health -= 10;
            if (user.health < 0) user.health = 0;
            return `${user.name} uses The Don! Deals 30 damage to ${target.name} and 10 damage to himself!`;
        }
    }
},
{ 
    name: "Rob", 
    avatar: "./Avatars/Rob.jpg",
    specialMove: {
        name: "Mr Simp",
        description: "Deals 30 damage to himself against female characters, and 10 damage to male opponents",
        effect: function (user, target)  {
            const femaleCharacters = ["Uma", "Cocowaves", "Chixxey", "Pix"];
            if (femaleCharacters.includes(target.name)) {
                user.health -= 30;
                if (user.health < 0) user.health = 0;
                return `${user.name} uses Mr Simp against ${target.name}! Deals 30 damage to himself!`;
            } else {
                target.health -= 10;
                if (target.health < 0) target.health = 0;
                return `${user.name} uses Mr Simp! Deals 10 damage to ${target.name}!`;
            }
        }
    }
}
            
        ];

     

  // Game Data (Skipping const characters as per instructions)
  const allCardTypes = [
    { name: "Slash", type: "attack", power: 15, icon: "âš”ï¸" },
    { name: "Fireball", type: "attack", power: 20, icon: "ðŸ”¥" },
    { name: "Crush", type: "attack", power: 25, icon: "ðŸ”¨" },
    { name: "Pierce", type: "attack", power: 18, icon: "ðŸ—¡ï¸" },
    { name: "Heal", type: "heal", power: 10, icon: "â¤ï¸" },
    { name: "Cure", type: "heal", power: 15, icon: "âœ¨" },
    { name: "Revive", type: "heal", power: 15, icon: "ðŸŒ¿" },
    { name: "Shield", type: "block", power: 0, icon: "ðŸ›¡ï¸", description: "Blocks half of next attack's damage" },
    { name: "Egg", type: "attack", power: 28, icon: "ðŸ¥š" }
  ];

  let roomId = null;

  // Game State
  const gameState = {
    player: null,
    ai: null,
    currentTurn: "player",
    gameOver: false,
    selectedCards: [],
    specialMoveUsed: false,
    nextAttackDoubled: false,
    isMultiplayer: false,
    opponent: null,
    roomId: null,
    restartRequested: false
  };

  // DOM Elements
  const elements = {
    characterSelect: document.getElementById('character-select'),
    characterGrid: document.getElementById('character-grid'),
    deckBuilder: document.getElementById('deck-builder'),
    cardOptions: document.getElementById('card-options'),
    startGameBtn: document.getElementById('start-game-btn'),
    gameContainer: document.getElementById('game-container'),
    playerName: document.getElementById('player-name'),
    aiName: document.getElementById('ai-name'),
    playerAvatar: document.getElementById('player-avatar'),
    aiAvatar: document.getElementById('ai-avatar'),
    playerHealthBar: document.getElementById('player-health-bar'),
    aiHealthBar: document.getElementById('ai-health-bar'),
    playerHealthText: document.getElementById('player-health-text'),
    aiHealthText: document.getElementById('ai-health-text'),
    playerDeck: document.getElementById('player-deck'),
    aiDeck: document.getElementById('ai-deck'),
    battleLog: document.getElementById('battle-log'),
    turnIndicator: document.getElementById('turn-indicator'),
    restartBtn: document.getElementById('restart-btn'),
    newGameBtn: document.getElementById('new-game-btn'),
    specialMoveBtn: document.getElementById('special-move-btn'),
    mainMenu: document.getElementById('main-menu'),
    normalModeBtn: document.getElementById('normal-mode-btn'),
    multiplayerBtn: document.getElementById('multiplayer-btn'),
    quitBtn: document.getElementById('quit-btn'),
    multiplayerMenu: document.getElementById('multiplayer-menu'),
    createRoomBtn: document.getElementById('create-room-btn'),
    joinRoomBtn: document.getElementById('join-room-btn'),
    joinRoomInput: document.getElementById('join-room-input'),
    roomCodeInput: document.getElementById('room-code'),
    submitRoomCode: document.getElementById('submit-room-code'),
    waitingArea: document.getElementById('waiting-area'),
    roomCodeDisplay: document.getElementById('room-code-display')
  };

  if (!elements.normalModeBtn) console.error("normalModeBtn not found! Check if <button id='normal-mode-btn'> exists in HTML.");
if (!elements.quitBtn) console.error("quitBtn not found! Check if <button id='quit-btn'> exists in HTML.");
if (!elements.mainMenu) console.error("mainMenu not found! Check if <div id='main-menu'> exists in HTML.");

  // Socket.io Connection
  const socket = io('https://card-battle-u4uz.onrender.com/');

  // **Socket Event Handlers**

  socket.on('connect', () => {
    gameState.socketId = socket.id;
    console.log('Connected to server with ID:', socket.id);
  });

  socket.on('roomCreated', ({ roomId }) => {
    console.log("âœ… Room created:", roomId);
    elements.waitingArea.style.display = 'block';
    elements.roomCodeDisplay.textContent = roomId;
    gameState.roomId = roomId;
    addToLog(`Room created. Code: ${roomId}. Waiting for opponent...`);
  });

  socket.on('playerJoined', ({ players, roomId }) => {
    console.log("ðŸŽ¯ playerJoined:", players, roomId);
    gameState.opponent = players.find(p => p.socketId !== socket.id);
    gameState.isMultiplayer = true;
    gameState.roomId = roomId;
    addToLog(`Opponent joined: ${gameState.opponent.name}`);

    socket.emit('playerReady', {
      roomId,
      deck: gameState.selectedCards,
      specialMove: gameState.player.specialMove
    });
  });

 socket.on('gameStarted', ({ players, currentTurn, roomId }) => {
  console.log("ðŸ§ª gameStarted:", { players, currentTurn, roomId });
  if (!roomId) {
    console.error('Invalid gameStarted payload: roomId missing', { players, currentTurn, roomId });
    addToLog('Error: Failed to start game. Missing room ID.');
    showNotification('Error: Game failed to start due to missing room ID.');
    newGame();
    return;
  }
  elements.multiplayerMenu.style.display = 'none';
  elements.gameContainer.style.display = 'flex';

  const localPlayer = players.find(p => p.socketId === socket.id);
  const opponent = players.find(p => p.socketId !== socket.id);

  if (!localPlayer || !opponent) {
    console.error("Failed to assign localPlayer or opponent", { players, socketId: socket.id });
    addToLog('Error: Failed to start game. Invalid player data.');
    showNotification('Error: Game failed to start due to invalid player data.');
    newGame();
    return;
  }

  gameState.player = {
    socketId: localPlayer.socketId,
    name: localPlayer.name,
    avatar: localPlayer.avatar,
    health: localPlayer.health ?? 100,
    deck: gameState.selectedCards,
    specialMove: reconstructSpecialMove(localPlayer.specialMove),
    specialMoveUsed: localPlayer.specialMoveUsed ?? false,
    deckSize: localPlayer.deckSize ?? 5,
    extraTurns: localPlayer.extraTurns ?? 0,
    shieldActive: localPlayer.shieldActive ?? false,
    nextAttackDoubled: localPlayer.nextAttackDoubled ?? false
  };

  gameState.opponent = {
    socketId: opponent.socketId,
    name: opponent.name,
    avatar: opponent.avatar,
    health: opponent.health ?? 100,
    deckSize: opponent.deckSize ?? 5,
    specialMove: reconstructSpecialMove(opponent.specialMove),
    specialMoveUsed: opponent.specialMoveUsed ?? false,
    extraTurns: opponent.extraTurns ?? 0,
    shieldActive: opponent.shieldActive ?? false,
    nextAttackDoubled: opponent.nextAttackDoubled ?? false
  };

  gameState.currentTurn = currentTurn === socket.id ? "player" : "opponent";
  gameState.isMultiplayer = true;
  gameState.roomId = roomId;
  gameState.gameOver = false;
  gameState.restartRequested = false; // Add this line
  playBackgroundMusic();
  elements.aiName.textContent = gameState.opponent.name;
  elements.aiAvatar.src = gameState.opponent.avatar;
  updateUI();
  animateCardsDrop();
  addToLog(`Battle begins: ${gameState.player.name} vs ${gameState.opponent.name}`);
  addToLog(gameState.currentTurn === "player" ? "You go first!" : `${gameState.opponent.name} goes first!`);
});

socket.on('cardPlayed', ({ playerId, cardIndex, card, newCard }) => {
  console.log("ðŸŽ´ cardPlayed received:", { playerId, cardIndex, card, newCard });
  if (playerId === socket.id) {
    // Update player's deck for consistency
    gameState.player.deck.splice(cardIndex, 1);
    gameState.player.deckSize = gameState.player.deck.length;
    if (newCard && gameState.player.deck.length < 5) {
      gameState.player.deck.push({ ...newCard });
      gameState.player.deckSize = gameState.player.deck.length;
      const newCardElement = document.createElement('div');
      newCardElement.className = `card ${newCard.type}`;
      newCardElement.innerHTML = `
        <div class="card-name">${newCard.name}</div>
        <div class="card-icon">${newCard.icon}</div>
        <div class="card-value">${newCard.power}</div>
      `;
      newCardElement.style.opacity = '0';
      elements.playerDeck.appendChild(newCardElement);
      setTimeout(() => {
        newCardElement.style.transition = 'opacity 0.5s';
        newCardElement.style.opacity = '1';
        if (gameState.currentTurn === "player" && !gameState.gameOver) {
          newCardElement.addEventListener('click', () => playCard(gameState.player.deck.length - 1));
        }
      }, 50);
    }
    addToLog(`${gameState.player.name} plays ${card.name}!`);
  } else {
    const opponentDeck = elements.aiDeck;
    const cardElement = opponentDeck.children[cardIndex];
    if (cardElement) {
      cardElement.innerHTML = `
        <div class="card-name">${card.name}</div>
        <div class="card-icon">${card.icon}</div>
        <div class="card-value">${card.power}</div>
      `;
      cardElement.classList.add('card-play-anim');
      if (card.name === "Crush") playCrushSound();
      else if (card.name === "Egg") playEggSound();
      else if (card.name === "Fireball") playFireballSound();
      else if (card.type === "attack") playAttackSound();
      else if (card.type === "heal") playHealSound();
      else if (card.name === "Shield") playShieldSound();
      setTimeout(() => {
        cardElement.classList.remove('card-play-anim');
        cardElement.remove();
        if (newCard && gameState.opponent.deckSize > elements.aiDeck.children.length) {
          const newCardElement = document.createElement('div');
          newCardElement.className = 'card ai-card';
          newCardElement.innerHTML = `<div style="font-size: 2rem;">â“</div>`;
          newCardElement.style.opacity = '0';
          opponentDeck.appendChild(newCardElement);
          setTimeout(() => {
            newCardElement.style.transition = 'opacity 0.5s';
            newCardElement.style.opacity = '1';
          }, 50);
        }
      }, 300);
      addToLog(`${gameState.opponent.name} plays ${card.name}!`);
    }
  }
  // Health and turn updates handled by gameStateUpdated
});

 socket.on('specialMoveApplied', ({ playerId, message, playerHealth, opponentHealth, extraTurn, doubleDamage }) => {
  if (playerId === socket.id) {
    gameState.player.health = playerHealth;
    gameState.opponent.health = opponentHealth;
    gameState.player.specialMoveUsed = true;
    if (doubleDamage) gameState.player.nextAttackDoubled = true;
    if (!extraTurn) gameState.currentTurn = "opponent";
  } else {
    gameState.player.health = opponentHealth;
    gameState.opponent.health = playerHealth;
    gameState.opponent.specialMoveUsed = true;
    if (doubleDamage) gameState.opponent.nextAttackDoubled = true;
    if (!extraTurn) gameState.currentTurn = "player";
    if (gameState.opponent.specialMove.name.includes("Dominance")) playDominanceSound();
    else if (gameState.opponent.specialMove.name.includes("Cat")) playCatSound();
    else if (gameState.opponent.specialMove.name.includes("Batman")) playBatmanSound();
    else if (gameState.opponent.specialMove.name.includes("Clown")) playClownSound();
    else if (gameState.opponent.specialMove.name.includes("Love")) playLoveSound();
    else if (gameState.opponent.specialMove.name.includes("Egg")) playEggySound();
    else if (gameState.opponent.specialMove.name.includes("Matrix")) playMatrixSound();
    else if (gameState.opponent.specialMove.name.includes("Dictator")) playDictatorSound();
    else if (gameState.opponent.specialMove.name.includes("Proofer") || gameState.opponent.specialMove.name.includes("Artiste") || gameState.opponent.specialMove.name.includes("Helper")) playHealerSound();
    else if (gameState.opponent.specialMove.name.includes("Simp")) playSimpSound();
    else playSpecialSound();
  }
  addToLog(message);
  updateUI();
});

  socket.on('gameOver', ({ winner }) => {
  gameState.gameOver = true;
  gameState.restartRequested = false;
  elements.restartBtn.textContent = "RESTART MATCH";
  if (winner === socket.id) {
    showNotification("YOU WIN!");
    playVictorySound();
    addToLog("You won the battle!");
  } else if (winner === null) {
    showNotification("DRAW!");
    playDrawSound();
    addToLog("The battle ends in a draw!");
  } else {
    showNotification("YOU LOSE!");
    playDefeatSound();
    addToLog("You lost the battle!");
  }
  document.querySelectorAll('.card').forEach(card => card.style.pointerEvents = 'none');
  elements.specialMoveBtn.disabled = true;
  updateUI();
});

  socket.on('restartRequested', ({ playerId, playerName }) => {
  if (playerId !== socket.id) {
    addToLog(`${playerName} wants to restart the match!`);
    showNotification(`${playerName} requested a restart. Click Restart to agree.`);
  }
});

  socket.on('opponentDisconnected', () => {
    showNotification("Opponent disconnected!");
    addToLog("Opponent disconnected. Returning to main menu.");
    setTimeout(newGame, 3000);
  });

  socket.on('error', (message) => {
    showNotification(`Error: ${message}`);
  });

  // **Sound Functions**

  function playBackgroundMusic() {
    const bgMusic = document.getElementById('bg-music');
    bgMusic.volume = 0.15;
    const promise = bgMusic.play();
    if (promise !== undefined) {
      promise.catch(() => showMusicPlayButton());
    }
  }

  function showMusicPlayButton() {
    const playButton = document.createElement('button');
    playButton.id = 'music-play-btn';
    playButton.textContent = 'â–¶ Play Music';
    playButton.style.position = 'fixed';
    playButton.style.bottom = '20px';
    playButton.style.left = '20px';
    playButton.addEventListener('click', () => {
      document.getElementById('bg-music').play();
      playButton.remove();
    });
    document.body.appendChild(playButton);
  }

  function playAttackSound() { document.getElementById('attack-sound').play(); }
  function playCrushSound() { document.getElementById('crush-sound').play(); }
  function playEggSound() { document.getElementById('egg-sound').play(); }
  function playHealSound() { document.getElementById('heal-sound').play(); }
  function playShieldSound() { document.getElementById('shield-sound').play(); }
  function playFireballSound() { document.getElementById('fireball-sound').play(); }
  function playVictorySound() { document.getElementById('victory-sound').play(); }
  function playDefeatSound() { document.getElementById('defeat-sound').play(); }
  function playSpecialSound() { document.getElementById('special-sound').play(); }
  function playDominanceSound() { document.getElementById('dominance-sound').play(); }
  function playBatmanSound() { document.getElementById('batman-sound').play(); }
  function playCatSound() { document.getElementById('cat-sound').play(); }
  function playLoveSound() { document.getElementById('love-sound').play(); }
  function playEggySound() { document.getElementById('eggy-sound').play(); }
  function playMatrixSound() { document.getElementById('matrix-sound').play(); }
  function playDictatorSound() { document.getElementById('dictator-sound').play(); }
  function playHealerSound() { document.getElementById('healer-sound').play(); }
  function playSimpSound() { document.getElementById('simp-sound').play(); }
  function playClownSound() { document.getElementById('clown-sound').play(); }

  // **Game Logic Functions**

  function showNotification(message, duration = 5000) {
    const notification = document.createElement('div');
    notification.className = 'notification';
    notification.textContent = message;
    document.body.appendChild(notification);
    setTimeout(() => notification.remove(), duration);
  }

  function initCharacterSelection() {
    elements.characterGrid.innerHTML = '';
    characters.forEach((character) => {
      const charElement = document.createElement('div');
      charElement.className = 'character-card';
      charElement.innerHTML = `
        <img class="character-avatar" src="${character.avatar}" alt="${character.name}">
        <div class="character-name">${character.name}</div>
        <div class="special-move-info">
          <div class="special-move-name">${character.specialMove.name}</div>
          ${character.specialMove.description}
        </div>
      `;
      charElement.addEventListener('click', () => selectCharacter(character, charElement));
      elements.characterGrid.appendChild(charElement);
    });
  }

  function selectCharacter(character, element) {
    document.querySelectorAll('.character-card').forEach(card => card.classList.remove('selected'));
    element.classList.add('selected');
    gameState.player = {
      name: character.name,
      avatar: character.avatar,
      health: 100,
      deck: [],
      isAI: false,
      specialMove: character.specialMove,
      specialMoveUsed: false,
      extraTurns: 0,
      shieldActive: false,
      nextAttackDoubled: false
    };
    elements.deckBuilder.style.display = 'block';
    initDeckBuilder();
  }

  function initDeckBuilder() {
    elements.cardOptions.innerHTML = '';
    allCardTypes.forEach((card) => {
      const cardElement = document.createElement('div');
      cardElement.className = 'card-option';
      cardElement.innerHTML = `
        <div style="font-size: 2rem;">${card.icon}</div>
        <div>${card.name}</div>
        <div>${card.power} ${card.type === 'attack' ? 'DMG' : 'HEAL'}</div>
      `;
      cardElement.addEventListener('click', () => toggleCardSelection(card, cardElement));
      elements.cardOptions.appendChild(cardElement);
    });
  }

  function toggleCardSelection(card, element) {
    const index = gameState.selectedCards.findIndex(c => c.name === card.name);
    if (index === -1 && gameState.selectedCards.length < 5) {
      gameState.selectedCards.push(card);
      element.classList.add('selected');
    } else if (index !== -1) {
      gameState.selectedCards.splice(index, 1);
      element.classList.remove('selected');
    }
  }

  function startGame() {
  if (gameState.selectedCards.length !== 5) {
    showNotification("Please select exactly 5 cards for your deck!");
    return;
  }
  playBackgroundMusic();
  elements.characterSelect.style.display = 'none';
  elements.gameContainer.style.display = 'flex';

  const aiCharacter = characters[Math.floor(Math.random() * characters.length)];
  gameState.ai = {
    name: aiCharacter.name,
    avatar: aiCharacter.avatar,
    health: 100,
    deck: generateRandomDeck(),
    deckInitial: null, // Will be set below
    isAI: true,
    specialMove: aiCharacter.specialMove,
    specialMoveUsed: false,
    extraTurns: 0,
    shieldActive: false,
    nextAttackDoubled: false
  };
  gameState.ai.deckInitial = [...gameState.ai.deck]; // Store initial AI deck

  gameState.player.deck = [...gameState.selectedCards];
  gameState.specialMoveUsed = false;
  gameState.isMultiplayer = false;
  gameState.currentTurn = "player";
  gameState.gameOver = false;

  console.log("Starting game with:", {
    player: gameState.player,
    ai: gameState.ai,
    selectedCards: gameState.selectedCards
  });

  initBattle();
}

function playCard(cardIndex) {
  if (gameState.gameOver || gameState.currentTurn !== "player") {
    console.log('playCard blocked:', { gameOver: gameState.gameOver, currentTurn: gameState.currentTurn });
    return;
  }

  const card = gameState.player.deck[cardIndex];
  if (!card) {
    console.error('Invalid card at index:', cardIndex);
    return;
  }

  const cardElement = elements.playerDeck.children[cardIndex];
  cardElement.classList.add('card-play-anim');

  if (card.name === "Crush") playCrushSound();
  else if (card.name === "Egg") playEggSound();
  else if (card.name === "Fireball") playFireballSound();
  else if (card.type === "attack") playAttackSound();
  else if (card.type === "heal") playHealSound();
  else if (card.name === "Shield") playShieldSound();

  setTimeout(() => {
    cardElement.classList.remove('card-play-anim');
    cardElement.remove();

    if (gameState.isMultiplayer) {
      console.log('Emitting playCard:', { roomId: gameState.roomId, cardIndex });
      socket.emit('playCard', { roomId: gameState.roomId, cardIndex });
      // Local updates deferred to gameStateUpdated
    } else {
      applyCardEffects(card, gameState.player, gameState.ai);
      gameState.player.deck.splice(cardIndex, 1);
      if (gameState.player.deck.length < 5) {
        const newCard = gameState.selectedCards[Math.floor(Math.random() * gameState.selectedCards.length)];
        gameState.player.deck.push({ ...newCard });
        setTimeout(() => {
          const newCardElement = document.createElement('div');
          newCardElement.className = `card ${newCard.type}`;
          newCardElement.innerHTML = `
            <div class="card-name">${newCard.name}</div>
            <div class="card-icon">${newCard.icon}</div>
            <div class="card-value">${newCard.power}</div>
          `;
          newCardElement.style.opacity = '0';
          elements.playerDeck.appendChild(newCardElement);
          setTimeout(() => {
            newCardElement.style.transition = 'opacity 0.5s';
            newCardElement.style.opacity = '1';
            if (gameState.currentTurn === "player" && !gameState.gameOver) {
              newCardElement.addEventListener('click', () => playCard(gameState.player.deck.length - 1));
            }
          }, 50);
        }, 300);
      }
      addToLog(`${gameState.player.name} plays ${card.name}!`);
      if (gameState.ai.health <= 0 || gameState.player.health <= 0) {
        endGame();
        return;
      }
      if (gameState.player.extraTurns > 0) {
        gameState.player.extraTurns--;
        addToLog(`${gameState.player.name} gets an extra turn!`);
        updateUI();
      } else {
        gameState.currentTurn = "ai";
        elements.turnIndicator.textContent = "AI TURN";
        updateUI();
        setTimeout(makeAIMove, 1000);
      }
    }
  }, 300);
}

function animateCardsDrop() {
  elements.playerDeck.innerHTML = '<div class="deck-placeholder">âœ§</div>';
  elements.aiDeck.innerHTML = '<div class="deck-placeholder">âœ§</div>';

  const deckSource = gameState.isMultiplayer ? gameState.player.deck : gameState.ai.deck;
  const opponentDeckSize = gameState.isMultiplayer ? gameState.opponent.deckSize : deckSource.length;

  for (let i = 0; i < 5; i++) {
    setTimeout(() => {
      const card = gameState.player.deck[i];
      if (card) {
        const cardElement = document.createElement('div');
        cardElement.className = `card ${card.type}`;
        cardElement.innerHTML = `
          <div class="card-name">${card.name}</div>
          <div class="card-icon">${card.icon}</div>
          <div class="card-value">${card.power}</div>
        `;
        cardElement.classList.add('card-deal-animation');
        elements.playerDeck.appendChild(cardElement);
        setTimeout(() => {
          cardElement.classList.remove('card-deal-animation');
          cardElement.style.position = '';
          if (gameState.currentTurn === "player" && !gameState.gameOver) {
            cardElement.addEventListener('click', () => playCard(i));
          }
        }, 800);
      }
    }, i * 300);

    setTimeout(() => {
      if (i < opponentDeckSize) {
        const cardElement = document.createElement('div');
        cardElement.className = 'card ai-card';
        cardElement.innerHTML = `<div style="font-size: 2rem;">â“</div>`;
        cardElement.classList.add('ai-card-deal-animation');
        elements.aiDeck.appendChild(cardElement);
        setTimeout(() => {
          cardElement.classList.remove('ai-card-deal-animation');
          cardElement.style.position = '';
        }, 800);
      }
    }, (i + 5) * 300);
  }

  setTimeout(() => {
    elements.playerDeck.querySelector('.deck-placeholder')?.remove();
    elements.aiDeck.querySelector('.deck-placeholder')?.remove();
    elements.turnIndicator.style.display = 'block';
  }, 3000);
}


  function getRandomCard() {
    const randomIndex = Math.floor(Math.random() * allCardTypes.length);
    return { ...allCardTypes[randomIndex] };
  }

  function generateRandomDeck() {
    const deck = [];
    const attackCards = allCardTypes.filter(card => card.type === "attack");
    const healCards = allCardTypes.filter(card => card.type === "heal");
    const blockCards = allCardTypes.filter(card => card.name === "Shield");
    for (let i = 0; i < 3; i++) deck.push({ ...attackCards[Math.floor(Math.random() * attackCards.length)] });
    deck.push({ ...healCards[Math.floor(Math.random() * healCards.length)] });
    deck.push({ ...blockCards[0] });
    return deck;
  }

  function initBattle() {
    gameState.gameOver = false;
    gameState.currentTurn = "player";
    gameState.specialMoveUsed = false;
    if (!gameState.isMultiplayer) {
      gameState.player.extraTurns = 0;
      gameState.ai.extraTurns = 0;
    }
    updateUI();
    animateCardsDrop();
  }

socket.on('gameStateUpdated', ({ players, currentTurn, roomId }) => {
  console.log("ðŸ”„ gameStateUpdated received:", { players, currentTurn, roomId });
  if (gameState.roomId !== roomId) {
    console.error('Room ID mismatch:', { expected: gameState.roomId, received: roomId });
    addToLog('Error: Room ID mismatch.');
    showNotification('Error: Game state sync failed due to room mismatch.');
    return;
  }
  const localPlayer = players.find(p => p.socketId === socket.id);
  const opponent = players.find(p => p.socketId !== socket.id);
  if (!localPlayer || !opponent) {
    console.error('Invalid gameStateUpdated payload', { players, currentTurn, roomId });
    addToLog('Error: Failed to update game state.');
    showNotification('Error: Game state sync failed.');
    return;
  }
  gameState.player.health = localPlayer.health;
  gameState.player.specialMoveUsed = localPlayer.specialMoveUsed || false;
  gameState.player.deckSize = localPlayer.deckSize;
  gameState.player.shieldActive = localPlayer.shieldActive || false;
  gameState.player.nextAttackDoubled = localPlayer.nextAttackDoubled || false;
  gameState.player.extraTurns = localPlayer.extraTurns || 0;
  gameState.opponent.health = opponent.health;
  gameState.opponent.specialMoveUsed = opponent.specialMoveUsed || false;
  gameState.opponent.deckSize = opponent.deckSize;
  gameState.opponent.shieldActive = opponent.shieldActive || false;
  gameState.opponent.nextAttackDoubled = opponent.nextAttackDoubled || false;
  gameState.opponent.extraTurns = opponent.extraTurns || 0;
  gameState.currentTurn = currentTurn === socket.id ? "player" : "opponent";
  renderDecks();
  updateUI();
  console.log("Updated gameState:", {
    playerHealth: gameState.player.health,
    opponentHealth: gameState.opponent.health,
    currentTurn: gameState.currentTurn,
    playerDeckSize: gameState.player.deckSize,
    opponentDeckSize: gameState.opponent.deckSize
  });
});
function renderDecks() {
  elements.playerDeck.innerHTML = '';
  elements.aiDeck.innerHTML = '';

  gameState.player.deck.forEach((card, index) => {
    const cardElement = document.createElement('div');
    cardElement.className = `card ${card.type}`;
    cardElement.innerHTML = `
      <div class="card-name">${card.name}</div>
      <div class="card-icon">${card.icon}</div>
      <div class="card-value">${card.power}</div>
    `;
    if (gameState.currentTurn === "player" && !gameState.gameOver) {
      cardElement.addEventListener('click', () => playCard(index));
    }
    elements.playerDeck.appendChild(cardElement);
  });

  const deckSize = gameState.isMultiplayer ? gameState.opponent.deckSize : gameState.ai.deck.length;
  for (let i = 0; i < deckSize; i++) {
    const cardElement = document.createElement('div');
    cardElement.className = 'card ai-card';
    cardElement.innerHTML = `<div style="font-size: 2rem;">â“</div>`;
    elements.aiDeck.appendChild(cardElement);
  }
}
  function applyCardEffects(card, user, target) {
    if (card.type === "attack" || card.name === "Egg") {
      let damage = card.power;
      if (user.nextAttackDoubled) {
        damage *= 2;
        addToLog(`Matrix Glitch doubles ${card.name}'s power to ${damage}!`);
        user.nextAttackDoubled = false;
      }
      if (target.shieldActive) {
        damage = Math.max(1, Math.floor(damage / 2));
        addToLog(`${target.name}'s Shield reduces damage to ${damage}!`);
        target.shieldActive = false;
      }
      target.health -= damage;
      if (target.health < 0) target.health = 0;
      addToLog(`${user.name} uses ${card.name} for ${damage} damage!`);
    } else if (card.type === "heal") {
      const healAmount = card.power;
      user.health += healAmount;
      if (user.health > 100) user.health = 100;
      addToLog(`${user.name} heals for ${healAmount} HP!`);
    } else if (card.name === "Shield") {
      user.shieldActive = true;
      addToLog(`${user.name} activates Shield! Next attack will be halved!`);
    }
  }

  function useSpecialMove() {
    if (gameState.gameOver || gameState.currentTurn !== "player" || gameState.player.specialMoveUsed) return;

    const player = gameState.player;
    const target = gameState.isMultiplayer ? gameState.opponent : gameState.ai;

    if (player.specialMove.name.includes("Founder Dominance")) playDominanceSound();
    else if (player.specialMove.name.includes("Cat")) playCatSound();
    else if (player.specialMove.name.includes("Batman")) playBatmanSound();
    else if (player.specialMove.name.includes("Clown")) playClownSound();
    else if (player.specialMove.name.includes("Love")) playLoveSound();
    else if (player.specialMove.name.includes("Egg")) playEggySound();
    else if (player.specialMove.name.includes("Matrix")) playMatrixSound();
    else if (player.specialMove.name.includes("Dictator")) playDictatorSound();
    else if (player.specialMove.name.includes("Proofer") || player.specialMove.name.includes("Artiste") || player.specialMove.name.includes("Helper")) playHealerSound();
    else if (player.specialMove.name.includes("Simp")) playSimpSound();
    else playSpecialSound();

    player.specialMoveUsed = true;
    const message = player.specialMove.effect(player, target);
    addToLog(message);

    if (gameState.isMultiplayer) {
      const extraTurnMoves = ["Botman", "Queen", "Love Bomb"];
      const doubleDamageMoves = ["Matrix Glitch"];
      socket.emit('useSpecialMove', {
        roomId: gameState.roomId,
        playerId: socket.id,
        message,
        playerHealth: player.health,
        opponentHealth: target.health,
        playerName: player.name,
        opponentName: target.name,
        specialMoveName: player.specialMove.name,
        extraTurn: extraTurnMoves.includes(player.specialMove.name),
        doubleDamage: doubleDamageMoves.includes(player.specialMove.name)
      });
    } else {
      if (target.health <= 0 || player.health <= 0) {
        endGame();
        return;
      }
      if (!["Botman", "Queen", "Love Bomb"].includes(player.specialMove.name)) {
        gameState.currentTurn = "ai";
        setTimeout(makeAIMove, 1000);
      }
    }
    updateUI();
  }

  function reconstructSpecialMove(specialMove) {
    const move = { name: specialMove.name, description: specialMove.description };
    switch (specialMove.name) {
      case "Founder Dominance":
        move.effect = (user, target) => {
          target.health -= 40;
          if (target.health < 0) target.health = 0;
          return `${user.name} uses Founder Dominance! Deals 40 damage to ${target.name}!`;
        };
        break;
      case "I am Batman":
        move.effect = (user, target) => {
          target.health -= 25;
          if (target.health < 0) target.health = 0;
          return `${user.name} uses I am Batman! Deals 25 damage to ${target.name}!`;
        };
        break;
      case "Cat Attack":
        move.effect = (user, target) => {
          target.health -= 20;
          if (target.health < 0) target.health = 0;
          return `${user.name} uses Cat Attack! Deals 20 damage to ${target.name}!`;
        };
        break;
      case "Dictator":
        move.effect = (user, target) => {
          target.health -= 35;
          if (target.health < 0) target.health = 0;
          return `${user.name} uses Dictator! Deals 35 damage to ${target.name}!`;
        };
        break;
      case "Eggscalibur":
        move.effect = (user, target) => {
          target.health -= 30;
          if (target.health < 0) target.health = 0;
          return `${user.name} uses Eggscalibur! Deals 30 damage to ${target.name}!`;
        };
        break;
      case "Botman":
        move.effect = (user, target) => {
          user.extraTurns = 1;
          return `${user.name} uses Botman! Gets one additional turn!`;
        };
        break;
      case "Artiste":
        move.effect = (user, target) => {
          user.health += 40;
          if (user.health > 100) user.health = 100;
          return `${user.name} uses Artiste! Heals 40 HP!`;
        };
        break;
      case "Queen":
        move.effect = (user, target) => {
          user.extraTurns = 1;
          return `${user.name} uses Queen! Gets one additional turn!`;
        };
        break;
      case "Labubu Rage":
        move.effect = (user, target) => {
          target.health -= 40;
          if (target.health < 0) target.health = 0;
          return `${user.name} uses Labubu Rage! Deals 40 damage to ${target.name}!`;
        };
        break;
      case "Mr Helper":
        move.effect = (user, target) => {
          user.health += 30;
          if (user.health > 100) user.health = 100;
          return `${user.name} uses Mr Helper! Heals 30 HP!`;
        };
        break;
      case "Mr Green":
        move.effect = (user, target) => {
          user.health += 25;
          if (user.health > 100) user.health = 100;
          return `${user.name} uses Mr Green! Heals 25 HP!`;
        };
        break;
      case "Love Bomb":
        move.effect = (user, target) => {
          target.health -= 5;
          if (target.health < 0) target.health = 0;
          user.extraTurns = 1;
          return `${user.name} uses Love Bomb! Deals 5 damage to ${target.name} and gets an extra turn!`;
        };
        break;
      case "The Clown":
        move.effect = (user, target) => {
          user.health -= 35;
          if (user.health < 0) user.health = 0;
          return `${user.name} uses The Clown! Deals 35 damage to himself!`;
        };
        break;
      case "Matrix Glitch":
        move.effect = (user, target) => {
          user.nextAttackDoubled = true;
          return `${user.name} uses Matrix Glitch! Next attack will deal double damage!`;
        };
        break;
      case "Mr Shipper":
        move.effect = (user, target) => {
          user.health += 20;
          if (user.health > 100) user.health = 100;
          target.health -= 20;
          if (target.health < 0) target.health = 0;
          return `${user.name} uses Mr Shipper! +20 HP to himself and -20 HP to ${target.name}!`;
        };
        break;
      case "Proofer Regen":
        move.effect = (user, target) => {
          user.health += 40;
          if (user.health > 100) user.health = 100;
          return `${user.name} uses Proofer Regen! +40 HP!`;
        };
        break;
      case "The Don":
        move.effect = (user, target) => {
          target.health -= 30;
          if (target.health < 0) target.health = 0;
          user.health -= 10;
          if (user.health < 0) user.health = 0;
          return `${user.name} uses The Don! Deals 30 damage to ${target.name} and 10 damage to himself!`;
        };
        break;
      case "Mr Simp":
        move.effect = (user, target) => {
          const femaleCharacters = ["Uma", "Cocowaves", "Chixxey", "Pix"];
          if (femaleCharacters.includes(target.name)) {
            user.health -= 30;
            if (user.health < 0) user.health = 0;
            return `${user.name} uses Mr Simp against ${target.name}! Deals 30 damage to himself!`;
          } else {
            target.health -= 10;
            if (target.health < 0) target.health = 0;
            return `${user.name} uses Mr Simp! Deals 10 damage to ${target.name}!`;
          }
        };
        break;
      default:
        move.effect = (user, target) => `${user.name} uses an unknown move!`;
    }
    return move;
  }

  function makeAIMove() {
  if (gameState.gameOver || gameState.currentTurn !== "ai") return;

  const ai = gameState.ai;
  const player = gameState.player;

  if (!ai.specialMoveUsed && (ai.health <= 50 || player.health <= 50)) {
    useAISpecialMove();
    return;
  }

  const cardIndex = Math.floor(Math.random() * ai.deck.length);
  const card = ai.deck[cardIndex];
  const cardElement = elements.aiDeck.children[cardIndex];

  if (card.name === "Crush") playCrushSound();
  else if (card.name === "Egg") playEggSound();
  else if (card.type === "attack") playAttackSound();
  else if (card.type === "heal") playHealSound();
  else if (card.name === "Shield") playShieldSound();

  cardElement.innerHTML = `
    <div class="card-name">${card.name}</div>
    <div class="card-icon">${card.icon}</div>
    <div class="card-value">${card.power}</div>
  `;
  cardElement.classList.add('card-play-anim');

  setTimeout(() => {
    cardElement.classList.remove('card-play-anim');
    applyCardEffects(card, ai, player);
    ai.deck.splice(cardIndex, 1);
    if (ai.deck.length < 5) {
      const initialCards = gameState.ai.deckInitial || ai.deck; // Store initial deck if not already
      gameState.ai.deckInitial = initialCards; // Save initial deck for future draws
      const newCard = initialCards[Math.floor(Math.random() * initialCards.length)];
      ai.deck.push({ ...newCard });
      setTimeout(() => {
        const newCardElement = document.createElement('div');
        newCardElement.className = 'card ai-card';
        newCardElement.innerHTML = `<div style="font-size: 2rem;">â“</div>`;
        newCardElement.style.opacity = '0';
        elements.aiDeck.appendChild(newCardElement);
        setTimeout(() => {
          newCardElement.style.transition = 'opacity 0.5s';
          newCardElement.style.opacity = '1';
        }, 50);
      }, 300);
    }

    if (player.health <= 0 || ai.health <= 0) {
      endGame();
      return;
    }

    if (ai.extraTurns > 0) {
      ai.extraTurns--;
      setTimeout(makeAIMove, 1000);
    } else {
      gameState.currentTurn = "player";
      updateUI();
    }
  }, 300);
}
  function useAISpecialMove() {
    const ai = gameState.ai;
    const player = gameState.player;

    playSpecialSound();
    ai.specialMoveUsed = true;
    const message = ai.specialMove.effect(ai, player);
    addToLog(message);

    if (player.health <= 0 || ai.health <= 0) {
      endGame();
      return;
    }

    if (ai.specialMove.name === "Botman" || ai.specialMove.name === "Queen" || ai.specialMove.name === "Love Bomb") {
      setTimeout(makeAIMove, 1000);
    } else {
      gameState.currentTurn = "player";
      updateUI();
    }
  }

  function endGame() {
    gameState.gameOver = true;
    const opponent = gameState.isMultiplayer ? gameState.opponent : gameState.ai;

    let winner;
    if (gameState.player.health <= 0 && opponent.health <= 0) winner = "draw";
    else if (gameState.player.health <= 0) winner = "opponent";
    else winner = "player";

    if (gameState.isMultiplayer) {
      socket.emit('gameOver', {
        roomId: gameState.roomId,
        winner: winner === "player" ? socket.id : (winner === "opponent" ? opponent.socketId : null)
      });
    } else {
      if (gameState.player.health <= 0) {
        showNotification("YOU LOSE!");
        playDefeatSound();
        addToLog(`${opponent.name} wins the battle!`);
      } else {
        showNotification("YOU WIN!");
        playVictorySound();
        addToLog("You won the battle!");
      }
      updateUI();
    }

    elements.turnIndicator.style.display = 'none';
    document.querySelectorAll('.card').forEach(card => card.style.pointerEvents = 'none');
    elements.specialMoveBtn.disabled = true;
  }

  function updateUI() {
  if (!gameState.player) return;

  elements.playerName.textContent = gameState.player.name || "PLAYER";
  elements.playerAvatar.src = gameState.player.avatar || "./Avatars/default.png";
  elements.playerHealthBar.style.width = `${gameState.player.health}%`;
  elements.playerHealthText.textContent = `${gameState.player.health}/100`;

  const opponent = gameState.isMultiplayer ? gameState.opponent : gameState.ai;
  if (opponent) {
    elements.aiName.textContent = opponent.name || "OPPONENT";
    elements.aiAvatar.src = opponent.avatar || "./Avatars/default.png";
    elements.aiHealthBar.style.width = `${opponent.health}%`;
    elements.aiHealthText.textContent = `${opponent.health}/100`;
  }

  elements.turnIndicator.textContent = gameState.currentTurn === "player" ? "YOUR TURN" : `${opponent?.name?.toUpperCase() || "OPPONENT"}'S TURN`;
  elements.specialMoveBtn.disabled = gameState.currentTurn !== "player" || gameState.player.specialMoveUsed || gameState.gameOver;
  elements.specialMoveBtn.textContent = gameState.player.specialMoveUsed ? "SPECIAL MOVE USED" : `USE ${gameState.player.specialMove?.name || "SPECIAL"}`;
  elements.restartBtn.textContent = gameState.restartRequested ? "WAITING FOR OPPONENT..." : "RESTART MATCH";
  elements.restartBtn.disabled = gameState.restartRequested && gameState.isMultiplayer;
  renderDecks();
}

  function addToLog(message) {
    const logEntry = document.createElement('div');
    logEntry.className = 'log-entry';
    logEntry.textContent = `> ${message}`;
    elements.battleLog.appendChild(logEntry);
    elements.battleLog.scrollTop = elements.battleLog.scrollHeight;
  }

  function restartMatch() {
  if (gameState.isMultiplayer) {
    if (!gameState.restartRequested) {
      gameState.restartRequested = true;
      socket.emit('requestRestart', { roomId: gameState.roomId });
      elements.restartBtn.textContent = "WAITING FOR OPPONENT...";
      elements.restartBtn.disabled = true;
      addToLog("You requested to restart the match!");
      showNotification("Waiting for opponent to restart...");
    }
  } else {
    if (!gameState.player || !gameState.ai) return;
    gameState.player.health = 100;
    gameState.ai.health = 100;
    gameState.currentTurn = "player";
    gameState.gameOver = false;
    gameState.player.specialMoveUsed = false;
    gameState.ai.specialMoveUsed = false;
    gameState.player.extraTurns = 0;
    gameState.ai.extraTurns = 0;
    gameState.player.deck = [...gameState.selectedCards];
    gameState.ai.deck = generateRandomDeck();
    elements.battleLog.innerHTML = '<div class="log-entry">Match restarted!</div>';
    updateUI();
    animateCardsDrop();
  }
}

  function newGame() {
    elements.mainMenu.style.display = 'flex';
    elements.gameContainer.style.display = 'none';
    elements.characterSelect.style.display = 'none';
    elements.multiplayerMenu.style.display = 'none';
    document.getElementById('bg-music').pause();
    document.getElementById('bg-music').currentTime = 0;
    const playButton = document.getElementById('music-play-btn');
    if (playButton) playButton.remove();

    elements.battleLog.innerHTML = '<div class="log-entry">System initialized. Battle ready.</div>';
    gameState.selectedCards = [];
    gameState.player = null;
    gameState.ai = null;
    gameState.opponent = null;
    gameState.isMultiplayer = false;
    initCharacterSelection();
  }

  // **Event Listeners**

  elements.startGameBtn.addEventListener('click', startGame);
  elements.newGameBtn.addEventListener('click', newGame);
  elements.restartBtn.addEventListener('click', restartMatch);
  elements.specialMoveBtn.addEventListener('click', useSpecialMove);
  elements.normalModeBtn.addEventListener('click', () => {
    elements.mainMenu.style.display = 'none';
    elements.characterSelect.style.display = 'flex';
  });
  elements.multiplayerBtn.addEventListener('click', () => {
    if (gameState.selectedCards.length === 5) {
      elements.characterSelect.style.display = 'none';
      elements.multiplayerMenu.style.display = 'flex';
    } else {
      alert("Please select exactly 5 cards first!");
    }
  });
 elements.quitBtn.addEventListener('click', () => {
  if (confirm("Are you sure you want to quit?")) {
    if (gameState.isMultiplayer && gameState.roomId) {
      socket.emit('leaveRoom', { roomId: gameState.roomId });
    }
    newGame(); // Return to main menu instead of about:blank
  }
});
  elements.createRoomBtn.addEventListener('click', () => {
    if (gameState.selectedCards.length === 5) {
      socket.emit('createRoom', {
        name: gameState.player.name,
        avatar: gameState.player.avatar,
        deck: gameState.selectedCards,
        specialMove: { name: gameState.player.specialMove.name, description: gameState.player.specialMove.description }
      });
    } else {
      alert("Please build your deck first!");
    }
  });
  elements.joinRoomBtn.addEventListener('click', () => {
    elements.joinRoomInput.style.display = 'flex';
  });
  elements.submitRoomCode.addEventListener('click', () => {
    const code = elements.roomCodeInput.value.trim().toUpperCase();
    if (code && gameState.player) {
      socket.emit('joinRoom', {
        roomId: code,
        playerData: {
          name: gameState.player.name,
          avatar: gameState.player.avatar,
          deck: gameState.selectedCards,
          specialMove: { name: gameState.player.specialMove.name, description: gameState.player.specialMove.description }
        }
      });
    } else {
      alert("Please select your character and deck first");
    }
  });

  // **Initialization**

  elements.mainMenu.style.display = 'flex';
  elements.characterSelect.style.display = 'none';
  elements.gameContainer.style.display = 'none';
  elements.multiplayerMenu.style.display = 'none';
  initCharacterSelection();
</script>    
</body>
</html>

